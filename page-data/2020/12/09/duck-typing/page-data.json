{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/2020/12/09/duck-typing/","result":{"data":{"site":{"siteMetadata":{"title":"Harry Park's Blog"}},"markdownRemark":{"id":"e73db6c7-b539-50f7-806e-5dd04c9d386f","excerpt":"JavaScript, TypeScript 그리고 Duck Typing에 대해서 구글링하면 많은 양의 검색 결과물을 볼 수 있다. 하지만 적절한 설명 없이 부정확한 용어를 혼용하기도 하고 (동적 타이핑, 다형성 등), 특히 Dynamic Programming Languages…","html":"<p>JavaScript, TypeScript 그리고 Duck Typing에 대해서 구글링하면 많은 양의 검색 결과물을 볼 수 있다. 하지만 적절한 설명 없이 부정확한 용어를 혼용하기도 하고 (동적 타이핑, 다형성 등), 특히 Dynamic Programming Languages와 Dynamically Typed Languages를 동의어로 여기는 등 명확함이 떨어지거나 아예 틀린 설명을 길게 늘어 놓은 글들도 많이 확인 할 수 있었다.</p>\n<p>이 포스트에서는 필요한 용어들만 사용해 TypeScript의 Typing 방식과 Duck Typing에 대해서 쉽게 설명한다.</p>\n<h2 id=\"typescript에서는-구조가-같으면-할당-가능하다\" style=\"position:relative;\"><a href=\"#typescript%EC%97%90%EC%84%9C%EB%8A%94-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EA%B0%99%EC%9C%BC%EB%A9%B4-%ED%95%A0%EB%8B%B9-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"typescript에서는 구조가 같으면 할당 가능하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript에서는 구조가 같으면 할당 가능하다</h2>\n<p>Java, C# 개발자에게 다음과 같은 코드를 보여주면 매우 기겁하면서 도망을 가려고 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassA</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassB</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\na <span class=\"token operator\">=</span> b\nb <span class=\"token operator\">=</span> a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Java를 기준으로 <code class=\"language-text\">b</code>는 명백하게 타입 <code class=\"language-text\">ClassB</code>로 부터 만들어진 객체이며 타입 <code class=\"language-text\">ClassA</code>의 인스턴스를 할당할 수 없다. 하지만 이 것이 놀랍게도 TypeScript에서는 가능하다.</p>\n<p>이처럼 <strong>구조</strong>가 같으면 같은 타입으로 간주하는 방식을 <em>Structural Typing</em>, Java/C# 등과 같이 <strong>이름</strong>을 기준으로 타입을 나누는 방식을 <em>Nominal Typing</em>이라 한다.</p>\n<p>Structural Typing은 구조 이용해 타입의 할당 가능성(Assignability)을 결정하는 방식이기 때문에 전통적인 Nominal Typing 방식보다 덜 엄격하고 개발자가 의도치 않은 실수를 할 가능성이 있다. 그럼에도 불구하고 왜 TypeScript를 Nominal Typing 방식을 사용하지 않았을까? 답은 저 아래…</p>\n<h2 id=\"typescript는-duck-typing-방식을-사용한다\" style=\"position:relative;\"><a href=\"#typescript%EB%8A%94-duck-typing-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"typescript는 duck typing 방식을 사용한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript는 Duck Typing 방식을 사용한다</h2>\n<p>위에서 설명했듯 TypeScript은 Structural Typing 방식을 사용하며, 타입의 할당 가능성 판단을 위해서 <strong>컴파일 타임</strong>에 <code class=\"language-text\">Duck Typing</code> 방식을 사용한다. Duck Typing은 일종의 프로그래밍 패턴인데 다음에서 조금 더 자세하게 설명한다.</p>\n<h3 id=\"키보드와-관련-없는-typing의-의미\" style=\"position:relative;\"><a href=\"#%ED%82%A4%EB%B3%B4%EB%93%9C%EC%99%80-%EA%B4%80%EB%A0%A8-%EC%97%86%EB%8A%94-typing%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"키보드와 관련 없는 typing의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>키보드와 관련 없는 Typing의 의미</h3>\n<p>Duck Typing을 처음 들었을 때 연상되는 뜻은 “키보드를 치고 있는 오리”였다.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/465e92c503da32b8b62591703379f263/f93b5/cartoon_duck.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxOSxh//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECETEh/9oACAEBAAEFAk+XQnZJGCz/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEABj8CKv8A/8QAHBAAAgICAwAAAAAAAAAAAAAAAAERURAhMWFx/9oACAEBAAE/IWPtwLy2QJSJlWGg/9oADAMBAAIAAwAAABBDz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExQVH/2gAIAQEAAT8QW2Fb6rY4bV4SbRFPI82ACKr6exBKArlpefIQAAPhP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"키보드치는 오리, 출처: https://theburningmonk.com/2015/05/why-i-like-golang-interfaces/\"\n        title=\"키보드치는 오리, 출처: https://theburningmonk.com/2015/05/why-i-like-golang-interfaces/\"\n        src=\"/static/465e92c503da32b8b62591703379f263/f93b5/cartoon_duck.jpg\"\n        srcset=\"/static/465e92c503da32b8b62591703379f263/e07e9/cartoon_duck.jpg 200w,\n/static/465e92c503da32b8b62591703379f263/f93b5/cartoon_duck.jpg 300w\"\n        sizes=\"(max-width: 300px) 100vw, 300px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>키보드치는 오리, 출처: <a href=\"https://theburningmonk.com/2015/05/why-i-like-golang-interfaces/\">https://theburningmonk.com/2015/05/why-i-like-golang-interfaces/</a></p></figcaption>\n  </figure></p>\n<p>C/C++과 Java를 주로 다루던 때였기에 <code class=\"language-text\">int</code>, <code class=\"language-text\">float</code> 등의 데이터 타입을 정하는 것은 너무나도 당연한 것이었고 Typing이라는 표현자체가 생소했다. Typing의 정확한 뜻은 Wikipedia에서 찾을 수 있다.</p>\n<blockquote>\n<p>Assigning a data type, termed typing, gives meaning to a sequence of bits such as a value in memory or some object such as a variable.</p>\n</blockquote>\n<p>약간의 초월 번역을 하자면, Typing은 메모리 안의 (의미를 알 수 없는) 값들에 데이터 타입을 할당함으로써 의미를 부여하는 것이다. 이 과정이 없었다면 아마도 변수과 같은 객체의 적절한 크기를 정하는 것도 어려웠을 것이다.</p>\n<h3 id=\"duck-test-와-귀추법\" style=\"position:relative;\"><a href=\"#duck-test-%EC%99%80-%EA%B7%80%EC%B6%94%EB%B2%95\" aria-label=\"duck test 와 귀추법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duck Test 와 귀추법</h3>\n<p>Duck Typing은 Duck Test로 부터 유래 되었다. Duck Test는 논리학의 추론 형식 중 <a href=\"https://ko.wikipedia.org/wiki/%EA%B7%80%EC%B6%94%EB%B2%95\">귀추법(Abductive reasoning)</a>을 이해하기 쉽게 비유한 것이다.</p>\n<blockquote>\n<p>그 것이 오리인지 100% 확실하지는 않다. 하지만 오리처럼 생겼고, 오리처럼 걷고, 오리처럼 헤엄치며, 오리처럼 꽥꽥 소리를 낸다. 이 정도의 추론 단서라면 내가 보는 것이 오리라고 판단해도 전혀 무리는 없을 것이다.</p>\n</blockquote>\n<p>Duck Test 기법은 확실한 증거가 없을 때 유용한 판단 도구이다. 현실에 어떤 문제가 주어졌을 때 정보의 부족으로 인하여 항상 이상적인 해답을 구할 수 만은 없기 때문이다. 이런 경우 현실적으로 만족할만한 해답을 찾아야 한다. 이와 관련한 문제 해결법으로 <a href=\"https://ko.wikipedia.org/wiki/%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1_%EC%9D%B4%EB%A1%A0\">발견법(Heuristic)</a>이라는 것이 있으니 참고하자.</p>\n<h3 id=\"duck-typing\" style=\"position:relative;\"><a href=\"#duck-typing\" aria-label=\"duck typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duck Typing</h3>\n<p>Duck Test로 부터 유레된 Duck Typing은 일종의 프로그래밍 패턴이다. 아래의 JavaScript 코드는 <code class=\"language-text\">someAnimal</code>이 오리인지 아닌지 판단하기 위한 기준으로써 <code class=\"language-text\">appearance</code>와 <code class=\"language-text\">quack</code> 함수를 체크한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> duck <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  appearance<span class=\"token operator\">:</span> <span class=\"token string\">\"feathers\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 깃털을 가졌다.</span>\n  <span class=\"token function-variable function\">quack</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">duck_quack</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">what</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>what <span class=\"token operator\">+</span> <span class=\"token string\">\" quack-quack!\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 꽥꽥거리는 기능을 가졌다.</span>\n  color<span class=\"token operator\">:</span> <span class=\"token string\">\"black\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 검은색이다.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> someAnimal <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  appearance<span class=\"token operator\">:</span> <span class=\"token string\">\"feathers\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 깃털을 가졌다</span>\n  <span class=\"token function-variable function\">quack</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token function\">animal_quack</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">what</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>what <span class=\"token operator\">+</span> <span class=\"token string\">\" whoof-whoof!\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 꽥꽥거리는 기능을 가졌다. 소리가 좀 다를 뿐.</span>\n  eyes<span class=\"token operator\">:</span> <span class=\"token string\">\"yellow\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 눈이 노랗다.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 오리인지 판단하는 함수. 깃털이 있고 꽥꽥거리는 기능이 있으면 오리이다.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">check</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">who</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>who<span class=\"token punctuation\">.</span>appearance <span class=\"token operator\">==</span> <span class=\"token string\">\"feathers\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> who<span class=\"token punctuation\">.</span>quack <span class=\"token operator\">==</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    who<span class=\"token punctuation\">.</span><span class=\"token function\">quack</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I look like a duck!\\n\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">check</span><span class=\"token punctuation\">(</span>duck<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n<span class=\"token function\">check</span><span class=\"token punctuation\">(</span>someAnimal<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Duck Typing이 아니더라도 JavaScript에서는 프로퍼티의 존재 유무(e.g. <code class=\"language-text\">in</code>)와 그 것의 타입을 체크(e.g. <code class=\"language-text\">typeof</code>)를 런타임에서 수행할 수 있는 기능을 제공하며 그것들은 방어코드 구현을 위해 흔하게 사용된다. 잘못된 인자 타입으로 함수를 호출하고 런타임 에러가 발생한 경우, 콘솔 창에 불친절한 에러메세지 하나 보여주고 앱은 더이상 동작하지 않는 상황을 막으려는 것이다.</p>\n<p>개발자 본인이 만든 함수를 사용하는 경우는 그냥 적절하게 사용하면 되므로 방어 코드를 아예 없앨 수 있다. 하지만 외부에 공개해야하는 API 함수는 방어 코드가 많으면 많을수록 견고한 API를 만들 수 있다. 따라서 함수를 견고하게 구현하기 위해서 각종 assertion과 예외처리 코드를 넣다 보면 배보다 배꼽이 더 커지는 상황도 발생한다.</p>\n<p>JavaScript의 큰 단점으로 보이는 위 상황은 추가적인 방어 코드를 제거하고도 타입을 검사할 수 있다면 해결할 수 있을 것이다. TypeScript 컴파일러는 컴파일 시점에 Duck Typing과 같은 방식으로 타입을 검사하여 컴파일 에러를 내 준다. 이 것을 <code class=\"language-text\">Structural Typing</code>이라 한다.</p>\n<h2 id=\"structural-typing\" style=\"position:relative;\"><a href=\"#structural-typing\" aria-label=\"structural typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structural Typing</h2>\n<p>뭔가 다를 것도 없이 컴파일 시점에 Duck Typing을 적용한 것이 Structural Typing이다. 어떤 타입의 이름(e.g. 클래스명, 인터페이스명)이나 그 것의 위치(e.g. 패키지, 모듈)와 상관 없이 <strong>내부적으로 같은 구조를 가지고 있다면 두 개의 타입은 같다</strong>고 보는 것이다.</p>\n<p>따라서 다음과 같이 literal 표기법으로 만들어진 아무 이름 없는 객체 조차도 그 것의 구조가 <code class=\"language-text\">interface A</code>와 같기 때문에 할당하는데 아무런 문제가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token punctuation\">{</span>\n  innerObj<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\na <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  innerObj<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// ok!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"nominal-typing-in-typescript\" style=\"position:relative;\"><a href=\"#nominal-typing-in-typescript\" aria-label=\"nominal typing in typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nominal Typing in TypeScript</h2>\n<p>TypeScript는 Nominal Types를 지원하지 않는다. 조사 결과, 그것은 <a href=\"https://github.com/Microsoft/TypeScript/issues/202\">논란</a> 중이며 TypeScript의 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Roadmap\">future roadmap</a>에 하나의 항목으로 올라와 있다는 것을 알게 되었다. 몇 년안에 TypeScript가 Nominal Types를 지원하는 것을 기대해 볼 수도 있겠다. 정식 지원과는 별개로 TypeScript에서 Nominal Types 구현을 위한 몇가지 트릭이 있다. 그 중 하나를 첫 예제에 적용해 본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassA</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> __nominal<span class=\"token operator\">:</span> <span class=\"token keyword\">void</span>\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassB</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> __nominal<span class=\"token operator\">:</span> <span class=\"token keyword\">void</span>\n  <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\na <span class=\"token operator\">=</span> b <span class=\"token comment\">// compile error!</span>\nb <span class=\"token operator\">=</span> a <span class=\"token comment\">// compile error!</span>\nb <span class=\"token operator\">=</span> c <span class=\"token comment\">// ok!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>왜 TypeScript는 처음부터 훨씬 엄격한 Nominal Typing 방식을 지원하지 않은 것일까? 이에 대한 짧은 의견을 내어 본다. TypeScript는 JavaScript의 Superset이기도 하며 <a href=\"https://en.wikipedia.org/wiki/Gradual_typing\">Gradual Typing</a> 방식을 도입하여 필요한 타입들만 우선적으로 적용해도 문제가 없다. 만약 JavaScript에서 여러 타입의 객체를 파라미터로 받을 수 있는 함수가 있다면 자연스럽게 Duck Typing 방식으로 프로그래밍 했을 것이다.</p>\n<p>하지만 TypeScript로 변환을 시작했을 때 그 것이 Nominal Typing 방식이면 기존의 방식과의 너무나도 갭이 너무 크기 때문에 한번에 수정해야할 부분이 너무 많아질 것 같다. 다시말해서, Structural Typing은 JavaScript와의 호환성을 높이기 위해서 채택된 것이 아닐까? 구체적인 예는 없가 없어서 설득력이 없지만 한번 조사해 봐야 하겠다.</p>\n<p>위의 코드를 작성하면 <code class=\"language-text\">a = b</code>에서 다음과 같은 에러가 출력되는데 마치 Nominal Typing 방식에서나 볼 수 있을 법한 에러 메세지들 볼 수 있다.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/840300780af81edee7c8f4db5aeafac7/9342c/nominal.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAcuCQL//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAZEAABBQAAAAAAAAAAAAAAAAABABARIUH/2gAIAQEAAT8hhGsDf//aAAwDAQACAAMAAAAQ/A//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAECAQE/EDV//8QAFxABAQEBAAAAAAAAAAAAAAAAAREAof/aAAgBAQABPxCGEMRThpv/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"TypeScript에서 Nominal Types 구현\"\n        title=\"TypeScript에서 Nominal Types 구현\"\n        src=\"/static/840300780af81edee7c8f4db5aeafac7/9342c/nominal.jpg\"\n        srcset=\"/static/840300780af81edee7c8f4db5aeafac7/e07e9/nominal.jpg 200w,\n/static/840300780af81edee7c8f4db5aeafac7/066f9/nominal.jpg 400w,\n/static/840300780af81edee7c8f4db5aeafac7/9342c/nominal.jpg 560w\"\n        sizes=\"(max-width: 560px) 100vw, 560px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>TypeScript에서 Nominal Types 구현</p></figcaption>\n  </figure></p>\n<p>참고로 다음 링크에서 TypeScript에서의 Nominal Types에 대한 조금 더 자세한 정보를 볼 수 있다.</p>\n<ul>\n<li><a href=\"https://medium.com/better-programming/nominal-typescript-eee36e9432d2\">언제 Nominal Types를 사용해야 하나</a></li>\n<li><a href=\"https://michalzalecki.com/nominal-typing-in-typescript/\">Nominal Types 구현을 위한 트릭들</a></li>\n</ul>\n<h2 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h2>\n<p>TypeScript는 컴파일 타임에 Duck Typing 방식을 적용하는 Structural Typing 방식을 사용한다. TypeScript에서도 Nominal Typing을 흉내내기 위한 트릭이 존재한다.</p>\n<p>끝.</p>\n<!--참고 https://en.wikipedia.org/wiki/Type_system-->","frontmatter":{"title":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","date":"December 13, 2020","description":null},"tableOfContents":"<ul>\n<li><a href=\"/2020/12/09/duck-typing/#typescript%EC%97%90%EC%84%9C%EB%8A%94-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EA%B0%99%EC%9C%BC%EB%A9%B4-%ED%95%A0%EB%8B%B9-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\">TypeScript에서는 구조가 같으면 할당 가능하다</a></li>\n<li>\n<p><a href=\"/2020/12/09/duck-typing/#typescript%EB%8A%94-duck-typing-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\">TypeScript는 Duck Typing 방식을 사용한다</a></p>\n<ul>\n<li><a href=\"/2020/12/09/duck-typing/#%ED%82%A4%EB%B3%B4%EB%93%9C%EC%99%80-%EA%B4%80%EB%A0%A8-%EC%97%86%EB%8A%94-typing%EC%9D%98-%EC%9D%98%EB%AF%B8\">키보드와 관련 없는 Typing의 의미</a></li>\n<li><a href=\"/2020/12/09/duck-typing/#duck-test-%EC%99%80-%EA%B7%80%EC%B6%94%EB%B2%95\">Duck Test 와 귀추법</a></li>\n<li><a href=\"/2020/12/09/duck-typing/#duck-typing\">Duck Typing</a></li>\n</ul>\n</li>\n<li><a href=\"/2020/12/09/duck-typing/#structural-typing\">Structural Typing</a></li>\n<li><a href=\"/2020/12/09/duck-typing/#nominal-typing-in-typescript\">Nominal Typing in TypeScript</a></li>\n<li><a href=\"/2020/12/09/duck-typing/#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>"},"previous":{"fields":{"slug":"/2020/12/08/create-svg-logo/"},"frontmatter":{"title":"Gatsby Blog 용 Animated SVG 로고 만들기"}},"next":null},"pageContext":{"id":"e73db6c7-b539-50f7-806e-5dd04c9d386f","previousPostId":"327863c8-8559-5af0-aaf6-65cfc6b3e36e","nextPostId":null}},"staticQueryHashes":["2841359383"]}