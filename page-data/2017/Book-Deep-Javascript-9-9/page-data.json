{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017/Book-Deep-Javascript-9-9/","result":{"data":{"site":{"siteMetadata":{"title":"Harry Park's Blog"}},"markdownRemark":{"id":"fa407ed6-072d-56d4-a60f-64216bf83229","excerpt":"{% asset_img cover.jpg%}  Chapter 9. 자바스크립트 표준 9.1. ECMAScript 6 표준 2015년 6월에 발표된 ECMAScript 6(ES6)은 ECMAScript 2015라고도 불린다. ES6과 ES 201…","html":"<p>{% asset_img cover.jpg%} </p>\n<h1>Chapter 9. 자바스크립트 표준</h1>\n<h2>9.1. ECMAScript 6 표준</h2>\n<p>2015년 6월에 발표된 ECMAScript 6(ES6)은 ECMAScript 2015라고도 불린다. ES6과 ES 2015가 같기 때문에 조금 헷갈린다. 기존의 표준에 추가적인 기능들과 조금 더 나은 프로그래밍 언어의 모습을 얹어 놓았다. 개인적으로는 vue.js 2를 이용해서 개발할때 필요하므로 자세히 정리한다.</p>\n<h3>9.1.1. 변수, 상수 선언 키워드(let, const)</h3>\n<h4>“const는 이전에 없었던 ‘상수’를 선언하는 기능이다.”</h4>\n<p>같은 변수를 const로 선언 후 다시 정의 하면 에러가 발생한다. </p>\n<p>{%codeblock \"\" lang:javascript%}\nconst a = 1;\na = 2; // 에러! 상수 변경 불가.\n{%endcodeblock%}</p>\n<h4>“let은 “변수”를 선언하는데 var와는 조금 다르다.”</h4>\n<p>var 와 다른 점은 다음 두가지이다.</p>\n<ol>\n<li>중복 선언이 불가능하다.</li>\n<li>다른 언어 처럼 중괄호를 이용한 블록 개념을 가지고 있다.</li>\n</ol>\n<p>{%codeblock \"\" lang:javascript%}\nconst a = 1;\na = 2; // 에러! 상수 변경 불가.</p>\n<p>let b = 1;\nlet b = 2; //에러! 중복 선언 불가.</p>\n<p>for (let i = 0; i &#x3C; 10; i++) {}\nconsole.log(i) // 에러! i는 이미 사라짐.\n{%endcodeblock%}</p>\n<h3>9.1.2. 함수 화살표 표현식</h3>\n<p>ES6에서는 익명 함수를 표현할 때 간단히 표현할 수 있는 화살표 표현식이 추가되었다.</p>\n<h4>“화살표 표현식이 생겼다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\nlet func;\nfunc = function (msg) {alert(msg);}\nfunc = (msg) => alert(msg);  // 이 둘은 동일하다.\n{%endcodeblock%}</p>\n<h4>“콜백 함수에서의 this가 달라졌다.”</h4>\n<p>기존의 익명함수는 <code class=\"language-text\">setTimeout</code>에 넘긴 익명함수의 컨텍스트가 global이었으나, 화살표 표현식을 통한 컨텍스트는 기존에 호출한 것이 유지되도록 바뀌었다. 이제 더이상 <code class=\"language-text\">_this</code>를 저장하지 않아도 될것 같다.<br>\n{%codeblock \"\" lang:javascript%}\nvar a = “global”;</p>\n<p>function Person() {\nthis.a = “local”;\n// 기존의 this\nsetTimeout(function() {\nconsole.log(“1. a is ” + this.a); // 1. a is global\n}, 100);\n// this를 저장해서 사용하기\nvar _this = this;\nsetTimeout(function() {\nconsole.log(“2. a is ” + _this.a); // 1. a is local\n}, 100);\n// 새로운 화살표 표현식 내에서의 this\nsetTimeout(() => console.log(“3. a is ” + this.a), 100); // 1. a is local\n}\nvar person = new Person();\n{%endcodeblock%}</p>\n<h4>“IIFE(Invoke Immediate Function Express)도 간단해졌다.”</h4>\n<p>괄호로 전체를 묶는 방법은 좀 달라졌으니, 주의 요망\n{%codeblock \"\" lang:javascript%}\n// 기존 방법\n(function(){\nalert(“msg”);\n}());\n// 새로운 방법\n(()=>{\nalert(“msg”);\n})();\n{%endcodeblock%}</p>\n<h3>9.1.3. 클래스(class) 키워드</h3>\n<p>새로 추가된 <code class=\"language-text\">class</code>는 진짜 class이다. <code class=\"language-text\">constructor()</code>에 생성자를 구현하고, <code class=\"language-text\">extends</code> 키워드로 서브클래스를 구현할 수 있으며, <code class=\"language-text\">super</code> 키워드를 이용할 수도 있다.\n{%codeblock \"\" lang:javascript%}\nclass Car {\nconstructor(name) {\nthis.name = name;\nthis.type = “Car”;\n}\ngetName() {\nreturn this.name;\n}\n}</p>\n<p>class SUV extends Car {\nconstructor(name) { // 생성자 함수\nsuper(name); // super 키워드 이용\nthis.type = “SUV”;\n}\ngetName() { // 함수 오버라이딩\nreturn super.getName() + ” is ” + this.type; // super키워드 이용\n}\n}</p>\n<p>let suv = new SUV(“My car”);\nconsole.log(suv.getName()); // My car is SUV\n{%endcodeblock%}</p>\n<h3>9.1.4. 객체 표현식 기능 확대</h3>\n<p>좀 더 향상된 방법의 객체 표현식이 만들어졌다.</p>\n<h4>“속성명과 변수명이 같을 때는 한번만 써도 된다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\nvar a = 1,\nb = 2,\nc = 3;</p>\n<p>// 기존의 방법\nvar obj = {\na: a,\nb: b,\nc: c\n};</p>\n<p>// 새로운 방법\nvar obj = {\na,\nb,\nc\n};\nconsole.log(obj); // Object {a=1, b=2, c=3}\n{%endcodeblock%}</p>\n<h4>“객체 표현식에 계산식이 들어갈 수 도 있다.”</h4>\n<p>계산식을 이용해서 객체를 선언하고 싶을 때, 기존에는 빈 객체 선언 후 코드로 추가 해야 했지만 그 부분이 개선되었다.<br>\n{%codeblock \"\" lang:javascript%}\n// 기존의 방법\nvar foo = 1;\nvar bar = {};\nbar[“bar” + ++foo] = foo;\nbar[“bar” + ++foo] = foo;\nbar[“bar” + ++foo] = foo;\nconsole.log(bar); // Object {bar2=2, bar3=3, bar4=4}</p>\n<p>// 새로운 방법\nlet newBar = {\n[“bar” + ++foo]: foo, [“bar” + ++foo]: foo, [“bar” + ++foo]: foo\n}\nconsole.log(newBar); // Object {bar2=2, bar3=3, bar4=4}\n{%endcodeblock%}</p>\n<h4>“function 키워드를 생략할 수 있고, getter/setter 정의가 단순해졌다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\n// function 키워드를 써야 하는 기존의 방법\nvar obj = {\nfunc: function() {\nalert(“msg”);\n}\n};\n// funciton 키워드를 생략할 수 있는 새로운 방법\nvar obj = {\nfunc() {\nalert(“msg”);\n}\n};\n// getter, setter를 설정을 위한 기존의 방법\n// obj.name에 접근하면 호출되는 함수들이다.\nObject.defineProperty(obj, “name”, {\nget: function() {\nreturn this.<em>name;\n},\nset: function(name) {\nthis.</em>name = name;\n},\n});\n// getter, setter를 설정을 위한 새로운 방법\nobj = {\n<em>name: “my name”,\nget name() {\nreturn this.</em>name;\n},\nset name(name) {\nthis._name = name;\n}\n};\n{%endcodeblock%}</p>\n<h3>9.1.5. 템플릿 문자열 표현식</h3>\n<p>템플릿 문자열 표현식은 <code class=\"language-text\">`</code>(역따옴표)를 이용한다. 아래의 예제와 같이 더 이상 <code class=\"language-text\">+</code> 로 문자열을 연결해서 붙일 필요도 없고, 멀티라인 문자열도 지원한다.  </p>\n<h4>문자열 템플릿 기본</h4>\n<p>{%codeblock \"\" lang:javascript%}\nlet foo = “bar”;</p>\n<p>// 템플릿 문자열\nconsole.log(<code class=\"language-text\">${foo} ${foo.toUpperCase()}</code>);</p>\n<p>// 멀티라인 지원\nconsole.log(<code class=\"language-text\">foo\nbar</code>);\n{%endcodeblock%}</p>\n<h4>Tagged template</h4>\n<p>책에서는 이 용어를 사용하지 않는다. 하지만, <a href=\"%22http://hacks.mozilla.or.kr/2015/08/es6-in-depth-template-strings-2/%22\">이곳</a>으로 그리고 <a href=\"%22https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals%22\">MDN</a>으로 부터 정식 명칭과 더 명확한 정보를 얻을 수 있었다. </p>\n<p>Tagged template 이란, 템플릿 문자열 앞에 어떤 함수의 이름을 붙이는 것이다. 이렇게 함으로써, 문자열을 가공하는 방법을 제공한다. 이를 활용하여 다국어를 지원, 이스케이핑, 템플릿 언어 등에 응용할 수 있다.</p>\n<p>Tag는 함수로 구현하며 다음과 같이 템플릿 문자열 앞에 붙여준다.\n{%codeblock \"\" lang:javascript%}\nfunction myTag (strings, values) {\nreturn “안녕?”\n}\nvar name = myTag <code class=\"language-text\">Hello?</code>;\nconsole.log(name); // 안녕?\n{%endcodeblock%}</p>\n<h3>9.1.6. Destructing</h3>\n<p>객체를 역으로 여러 개의 변수에 할당하는 것을 의미한다. 좌측값(lvalue)에 <code class=\"language-text\">[]</code>이나 <code class=\"language-text\">{}</code>가 있으면 Destructing이라고 보면 된다.</p>\n<h4>“배열을 Destucting 한다.”</h4>\n<p>배열의 값을 순서대로 변수에 할당한다.\n{%codeblock \"\" lang:javascript%}\nvar myArray = [1, 2, 3, 4, 5];\n// 각각의 변수에 myArray의 값들을 할당함. 여기서 3은 버려진다.\nvar [a, b, , c, d] = myArray;\n// swap 예제. lvalue에 쓰인 []은 destructing\n[a, b] = [b, a];\n{%endcodeblock%}</p>\n<h4>“객체 Destructing 한다.”</h4>\n<p>객체의 value(키 빼고)를 각각의 변수에 할당한다.\n{%codeblock \"\" lang:javascript%}\n// 객체의 경우, 객체의 속성명으로 변수로 만든다.\nvar foo = {\nbar : “I’m bar”\n};\nvar {\nbar\n} = foo;\nconsole.log(bar); // I’m bar\n{%endcodeblock%}</p>\n<h4>“깊이가 있는 객체를 Destructing 한다.”</h4>\n<p>깊이가 있는 객체의 경우, 객체로 받을 수도, 내부 객체를 풀어서 받을지 표현식으로 결정할 수 있다.\n{%codeblock \"\" lang:javascript%}\nvar foo = {\nbar: {\nbar1: “I’m bar1”,\nbar2: “I’m bar2”\n}\n};\nvar {\nbar,\nbar: {\nbar1,\nbar2\n}\n} = foo;\nconsole.log(bar); // Object {bar1: “I’m bar1”, bar2: “I’m bar2”}\nconsole.log(bar1); // I’m bar1\nconsole.log(bar2); // I’m bar2\n{%endcodeblock%}</p>\n<h4>“Destructing 할 때, 기본 값 지정이 가능하다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\nvar arr = [1, 2];\nvar [a = 5, b = 6, c = 7, d = 8] = arr;\nconsole.log(a, b, c, d); // 1 2 7 8\n{%endcodeblock%}</p>\n<h4>“함수의 파라미터를 받을 때, Destructing 가능하다.”</h4>\n<p><code class=\"language-text\">[]</code>의 의미에 대해서 조금 헷갈리는 부분이 있는데, 어떤 것이 array이고 어떤 것이 destructing인지 잘 구분해야 한다.\n{%codeblock \"\" lang:javascript%}\nfunction func([foo,bar]) { // destructing\nconsole.log(foo, bar);\nreturn [bar,foo] // array\n}\nvar [a,b]/* destructing <em>/ = func([“a”,“b”]);  /</em> array */\nconsole.log(a, b);\n{%endcodeblock%}</p>\n<h3>9.1.7. 함수 인자 기능 확대</h3>\n<p>당연히 있어야할 것이 지금 나오 느낌.</p>\n<h4>“가변인자 사용이 가능해 졌다.”</h4>\n<p>기존의 방법은 <code class=\"language-text\">arguments</code>에 <code class=\"language-text\">Array.prototype.slice()</code>함수를 적용해서 남은 배열을 파라미터를 가져와야 했으나 이제는 <code class=\"language-text\">...</code> 붙이면 된다.\n{%codeblock \"\" lang:javascript%}\nfunction func(arg1, …rest) {\nconsole.log(arg1, rest);\n}\nfunc(1,2,3,4); // 1 [2, 3, 4]\n{%endcodeblock%}</p>\n<p>반대로, 호출하는 쪽에 <code class=\"language-text\">...</code>을 붙이면 배열을 펼쳐서 각각의 파라미터로 전달하게 된다.</p>\n<p>{%codeblock \"\" lang:javascript%}\nfunction func(a, b, c, d) {\nconsole.log(a, b, c, d, );\n}\nfunc(…[1, 2, 3, 4]); // 1 2 3 4\n{%endcodeblock%}</p>\n<h4>“함수 인자에 기본값 설정이 가능하다.”</h4>\n<p>이전에는 파라미터에 대한 Falsy 체크로 <code class=\"language-text\">param1 = param1 || &quot;default&quot;</code>을 써야 했지만, 이제는 그러지 않아도 된다.\n{%codeblock \"\" lang:javascript%}\nfunction func(a = 1, b = 2, c = 3) {\nconsole.log(a, b, c);\n}\nfunc(4, null, undefined);\n{%endcodeblock%}</p>\n<p>주의할 점은 <code class=\"language-text\">undefined</code>에 대해서만 기본값을 할당하며, <code class=\"language-text\">null</code>/<code class=\"language-text\">0</code>/<code class=\"language-text\">false</code>/<code class=\"language-text\">&quot;&quot;</code>을 체크하던 기존의 <code class=\"language-text\">param1 = param1 || &quot;default&quot;</code> 패턴과는 다르다는 것이다.</p>\n<h3>9.1.8. iterator와 for-of 기능</h3>\n<p>이 부분은 쉽지 않다. 이해해야 할 것이 좀 있다. <code class=\"language-text\">TODO: 나중에 다시 정리 예정</code> </p>\n<h3>9.1.9. Map과 Set 기능 추가</h3>\n<p>자바스크립트에는 없었던 유용한 자료구조가 추가되었다. Map과 Set은 각각 필수 함수들을 내장하고 있으며, iterator가 구현되어 있다.</p>\n<h4>“Set과 Map 클래스가 추가되었다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\n// Map\nvar map = new Map().set(“key1”, “value1”).set(“key2”, “value2”);\nfor (let [key, val] of map.entries()) {\nconsole.log(key, val);\n}\n// Set\nvar set = new Set().add(“value1”).add(“value2”);\nfor (let val of set.values()) {\nconsole.log(val);\n}\n{%endcodeblock%}</p>\n<h4>“WeakSet과 WeakMap”은 reference가 없어지면 요소가 삭제된다.”</h4>\n<p>{%codeblock \"\" lang:javascript%}\nvar obj = {\ndata: “foo”\n};\nvar set = new WeakSet().add(obj);\nconsole.log(set.has(obj)); // true\nobj = null;\nconsole.log(set.has(obj)); // false\n{%endcodeblock%}</p>\n<h3>9.1.10. Binary/Octal 표현식 추가</h3>\n<p>{%codeblock \"\" lang:javascript%}\nconsole.log(0b11111111); // 255\nconsole.log(0xFF); // 255\n{%endcodeblock%}</p>\n<h3>9.1.11. TypedArray 기능 추가</h3>\n<p>Raw 데이터를 만들고 조작할 수 있는 방법을 제공한다. 웹에서도 socket, video, sound와 같은 데이터를 다루기 시작해면서 필요해 졌다. <a href=\"%22https://developer.mozilla.org/ko/docs/Web/JavaScript/Typed_arrays%22\">MDN</a> 문서에 친절하게도 한글로 잘 설명되어 있다. 버퍼와 뷰 부분으로 나누어져 있는데, 버퍼에 직접 접근할 수 없고, 뷰를 통해서 접근한다. <code class=\"language-text\">ArrayBuffer()</code> 는 버퍼를 위해 사용하고, <code class=\"language-text\">Unint32Array()</code>와 같은 생성자는 뷰를 생성하기 위해서 사용한다.\n{%codeblock \"\" lang:javascript%}\nvar arrayBuffer = new ArrayBuffer(5); // 5바이트 버퍼 생성\nvar num = new Uint32Array(arrayBuffer, 0, 1);\nvar ch = new Uint8Array(arrayBuffer, 4, 1);</p>\n<p>num[0] = 0xFFFFFFFF;\nch[0] = 0xFF;</p>\n<p>console.log(num); // Uint32Array [4294967295]\nconsole.log(ch); // Uint8Array [255]\n{%endcodeblock%}</p>\n<h3>9.1.12. 모듈 기능 표준화</h3>\n<p>Node.js와 CommonJS로 부터 활성화 되기 시작해서 이번 표준에 정의 되었다. <code class=\"language-text\">export</code>로 각 파일에서 모듈을 정의하고, <code class=\"language-text\">import</code>로 사용한다. export는 두 가지 종류가 있는데, <code class=\"language-text\">named export</code>와 <code class=\"language-text\">default export</code>이다. </p>\n<p>{%codeblock \"\" lang:javascript%}\n// module.js\nexport function foo() {}\nexport default bar function() {}</p>\n<p>//app.js\nimport mybar, {foo} from “a.js”;\n{%endcodeblock%}</p>\n<p><code class=\"language-text\">mybar</code>에는 <code class=\"language-text\">{}</code>가 필요 없고, <code class=\"language-text\">default export</code>인 로 설정한 <code class=\"language-text\">bar</code>가 불려온다. 그 외엔 모두 <code class=\"language-text\">{}</code> 안에 넣어야 한다. 나머지 정확한 규칙들은 <a href=\"%22https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import%22\">MDN</a> 을 참고하면 된다.    </p>\n<h3>9.1.13. 프락시 모듈</h3>\n<p>{%codeblock \"\" lang:javascript%}\nvar foo = {\nbar: 1\n};</p>\n<p>// get할 때 속성 존재 여부 체크와 에러 코드를 리턴해주는 Proxy 객체\nvar fooProxy = new Proxy(foo, {\nget(foo, name) {\nreturn name in foo ? foo[name] : “ERROR 111: 없엉.”;\n}\n});</p>\n<p>console.log(fooProxy.a); // ERROR 111: 없엉.\nconsole.log(fooProxy.bar); // 1\n{%endcodeblock%}</p>\n<h3>9.1.14. Symbol 모듈</h3>\n<p>이 책은 Symbol에 대한 제대로된 정의와 필요성에 대해서 설명하고 있지 않은데다가 예제 또한 유용하지 않은 것이다. 이에 대해서는 <a href=\"%22http://hacks.mozilla.or.kr/%22\">Hacks Mozillar</a>에 잘 나와있다. Symbol은 유일한 값을 갖는 속성 키를 만드는데 쓰인다. 만약 내가 라이브러리를 만들어서 html의 특정 엘리멘트에 나만의 속성을 추가했다고 가정한다. 그런 속성명은 다른 라이브러리와 충돌할 수 밖에 없다. 이 때 Symbol()을 사용한다.\n{%codeblock \"\" lang:javascript%}\n// 파라미터로 들어가는 값은 주석이다. 디버깅용 출력에 사용된다.\nconsole.log(Symbol(“abcd”));</p>\n<p>// 매번 생성한 심벌은 다르다.\nconsole.log(Symbol() === Symbol());</p>\n<p>// window에 속성으로 등록한다 해도, 변수명이나 함수명에 대한 충돌을 신경쓰지 않아도 된다.\nvar myFunc = () => {console.log(“myFunc”)};\nvar myFuncSym = Symbol(“myFunc”);</p>\n<p>// 등록과 호출\nwindow[myFuncSym] = myFunc;\nwindow<a href=\"\">myFuncSym</a>;\n{%endcodeblock%}</p>\n<h3>9.1.15. Promise 모듈</h3>\n<p>비동기 함수를 Chaining하기 위한 하나의 방식을 제공한다. </p>\n<p>{%codeblock \"\" lang:javascript%}\n// Promise 생성자에는 resolve와 reject를 받는다.\nvar asyncFunc = new Promise((resolve, reject) => {\n// 여기서 시간이 걸리는 비동기 작업… 예) XMLHttpRequest()\n// 해당 비동기 성공하면 resolve(), 실패하면 reject()이 호출되도록 콜백 구성.\nresolve(“success message”);\nreject(“fail message”);\n});</p>\n<p>asyncFunc\n.then((msg) => { // resolve()에 의해 호출됨.\nconsole.log(“SUCCESS:” + msg);\n})\n.catch((msg) => { // reject()에 의해 호출됨.\nconsole.log(“FAIL:” + msg);\n});\n{%endcodeblock%}</p>","frontmatter":{"title":"[Book Summary] 속깊은 JavaScript 빠르게 읽기 9/9","date":"June 29, 2017","description":null}},"previous":{"fields":{"slug":"/2017/book-summary/deep-javascript/"},"frontmatter":{"title":"속깊은 JavaScript 빠르게 읽기"}},"next":{"fields":{"slug":"/2020/11/23/new-beginnings/"},"frontmatter":{"title":"새로운 시작"}}},"pageContext":{"id":"fa407ed6-072d-56d4-a60f-64216bf83229","previousPostId":"e34476d5-2ac4-50e7-9c00-1829bc507a83","nextPostId":"b25f88d7-858f-57e1-890c-283a6dc8cc3a"}},"staticQueryHashes":["2841359383","916993862"]}