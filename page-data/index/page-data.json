{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Harry Park's Blog"}},"allMarkdownRemark":{"nodes":[{"excerpt":"JavaScript, TypeScript 그리고 Duck Typing에 대해서 구글링하면 많은 양의 검색 결과물을 볼 수 있다. 하지만 적절한 설명 없이 부정확한 용어를 혼용하기도 하고 (동적 타이핑, 다형성 등), 특히 Dynamic Programming Languages와 Dynamically Typed Languages를 동의어로 여기는 등 명확함이 떨어지거나 아예 틀린 설명을 길게 늘어 놓은 글들도 많이 확인 할 수 있었다. 이 포스트에서는 필요한 용어들만 사용해 TypeScript의 Typing 방식과 Duck Typing에 대해서 쉽게 설명한다. TypeScript에서는 구조가 같으면 할당 가능하다 Java, C# 개발자에게 다음과 같은 코드를 보여주면 매우 기겁하면서 도망을 가려고 할 것이다. Java를 기준으로 는 명백하게 타입 로 부터 만들어진 객체이며 타입 의 인스턴스를 할당할 수 없다. 하지만 이 것이 놀랍게도 TypeScript…","fields":{"slug":"/2020/12/09/duck-typing/"},"frontmatter":{"date":"December 13, 2020","title":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKUlEQVQoz2NIqu9NrOvBRPF1/eHVUyJrpiTUYVcA1MgApBJqu5FRfG1Pcm2Hf/V8y7oTljVHwqqnJtV2oqkBIqBGLJrjarpT6to9yucnzbpVu+pOZO20hBqg5h6iNKc09KXU94RVTgiuXZTasTSxYUJSXXdiPSHNiXXdsdWd9VMX9C1c1b9w5dSlqyYvWdk2a/GUpeu6568AGhpf00XA5oTqjrz2ycU9M5JrOlJqO9Mb+4u6pmW3TiTsbGAYhhXWBudWRVe0heRV+6YVRpe3RpW3RhQ3EtYM5MZWtofmV8dUtEaVNIUX1obkVPilFkQU1yXW9xIOsIS6nrjqzqDsssDMktC86uiy5oiSBiCJaQ0DlkQClKjvjavuADohrgpItgFRIlg1WiIBAKoCHEH/hULxAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/3891b/thumbnail.png","srcSet":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/95f17/thumbnail.png 150w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/37d5a/thumbnail.png 300w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"개인 블로그에 로고가 왜 필요할까? 처음 블로그를 만들 당시는 필요 없을 것이라 생각했다. 하지만 로고는 과 무관하지 않았기에 어쩔 수 없이 만들어야 하는 것이었다. 큰 사이즈의 로고를 만들면 그 것을 리사이징하여 Favicon에 사용할 수 있기 때문이다. 이 포스트에서는 Animated SVG 로고를 만들고 블로그 첫 화면에 적용하는 과정을 설명한다. Favicon에 사용할 로고가 필요한 이유 모바일 기기 세상이 도래하면서 Favicon이 쓰임이 과거와는 많이 달라졌다. 데스크탑의 IE가 주류였던 시절에는 웹브라우저 상단의 탭에 아이콘을 표시하기 위해서 의 작은 크기의 만 제공하면 됐다. 하지만 현재는 데스크탑 뿐만 아니라 모바일 기기에서도 바탕화면에 웹사이트의 바로가기를 생성하는 기능을 제공하고 있으며 디스플레이의 해상도가 높아지면서 으로는 더이상 괜찮은 퀄리티의 아이콘을 제공할 수 없게 되었다.  이에 따라 Favicon…","fields":{"slug":"/2020/12/08/create-svg-logo/"},"frontmatter":{"date":"December 08, 2020","title":"Gatsby Blog 용 Animated SVG 로고 만들기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/0lEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1on/muY6pFybPv9I743xi/gErn80OQUTZvMUvbkdg4nbfmI1BcStiMrcEJu628dtClGbHoG1mXpvDkxetWL3n7NkL8VnLTT22OAYT52en4G3Gbhvr27d8eP/0//8/s+Yf1Hda5Ryyg7jQDtpi7bc9OGHJxQtnT50+U1632NxznWPwdmLj2T5wm53fWs/QOdZeC6x81gK5WJUBABZhDKLDMDULAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/fd44ab446f102955cb285d61692c532d/3891b/thumbnail.png","srcSet":"/static/fd44ab446f102955cb285d61692c532d/95f17/thumbnail.png 150w,\n/static/fd44ab446f102955cb285d61692c532d/37d5a/thumbnail.png 300w,\n/static/fd44ab446f102955cb285d61692c532d/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"이 포스트에서는 Table of Contents(목차) Component를 만들고 본문 우측 상단에 위치시키는 과정에 대해서 알아본다. TableOfContent 필드 확인 각 markdown 문서의 목차는 이미 플러그인에 의해서 HTML로 만들어져 있다. 이 플러그인은 에 기본적으로 들어 있는 플러그인으로 markdown문서를 HTML 문서로 변환해주는 역할을 한다. GraphQL 콘솔에서 위와 같이 쿼리해보면 노드의 tableOfContents 필드에 HTML 이 들어 있는 것을 알 수 있다. 스타일은 적용되어 있지 않으며,  형태의 링크까지 제공된다. 어떤 블로그에서는 결과물로써 HTML이 나오기 때문에 이 것을 활용하려면 파싱이 필요하다 한다. HTML이 아닌 데이터구조로 목차가 제공되는 로의 전환을 고려하는 방법도 있다. 아마 특정 UI framework을 적용 했을 경우 제공되는 와 류의 Component…","fields":{"slug":"/2020/12/03/add-table-of-content-gatsby/"},"frontmatter":{"date":"December 03, 2020","title":"Gatsby Blog에 목차 추가하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7ElEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1om/G2fap56fMv9Q7/VxS/gErn80OQcTZ7Bu7PSRlp3/89oD4bbE5uwMSdtn4bSFWs1Pwtpyq44V1J4FkdPYBp5BtdgHE+dk2YItbxI6W/vOdUy429Z7LrT7uEbkT6G1iA8wlbHte7fHChpM5Ncfj8g66hu+wC9hCbDwDkbXvZgiywWYnBAEAatQJr+GXWmsAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/eec42787b5f023fb867a219b41e32841/3891b/thumbnail.png","srcSet":"/static/eec42787b5f023fb867a219b41e32841/95f17/thumbnail.png 150w,\n/static/eec42787b5f023fb867a219b41e32841/37d5a/thumbnail.png 300w,\n/static/eec42787b5f023fb867a219b41e32841/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"JavaScript(ES6)에서  기호는 두 가지로 용법으로 쓰인다. Spread Operator와 Rest Parameter이다. 각각의 문법은 레퍼런스 문서에 상세하게 설명되어 있이며 이미 경험적으로 익숙해진 사람들에게는 그렇게 어렵지 않다. 하지만 처음 타입스크립트를 접한 사람들이 두 개의 용법이 섞인 복잡한 코드를 본다면 적잖게 혼란스러울 수 있다. 대부분 따로 설명되어 있는 이 두 개의 용법을 하나로 묶어서 쉽게 설명하는 것이 이 포스트의 목적이다. 만만한 Spread부터 파헤치자 spread operator는 iterable 객체를 함수의 인자 혹은 배열 literal의 요소로 확장한다. 조금 더 쉽게 말하면 배열과 같은 복수개의 데이터를 가진 데이터형을 으로 구분되는 여러개의 요소로 펼치는(spread) 곳에 사용한다는 것이다. 함수의 인자로 펼치기 대표적인 사용법 중 하나는 Iterable…","fields":{"slug":"/2020/12/02/rest-and-spread-in-javascript/"},"frontmatter":{"date":"December 02, 2020","title":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+Cobp3UzT2onSzDK1jWFWf0xD7P9sjV/1Hvr9JGkGkjO6VXorcmrCk6pCxSY3MszsZp5OyNkg305tM1s5z3/9MveNKz23b/LYsdll3dLkHRusVi1gmNzKNL2TgM28M7pFZvaKzOoVm9ktPqtHcGaP4rxJQEEGTJdjccyMTqA7gU5gAIYcBM3oAiHCfp7SxjB/EsO8iUAG+4xuFqCeKW2Mc/oZFkwGSRHQDLRnVi/D7D4gA+hDRqAngSKze0FoKjHOJhoBABmG5+pH0J5FAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png","srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/95f17/thumbnail1.png 150w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/37d5a/thumbnail1.png 300w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"TypeScript는 JavaScript의 관점에서 벗어나지 못한 상태로 접했을 때 매우 이상하게 느껴질 때가 있다. 이 포스트에서는 그런한 점 중 하나였던 index signatures에 대해서 이해하기 쉽게 설명하고자 한다. TypeScript에서는 안되는 것이 있다? TypeScript는 기본적으로 객체의 프로퍼티를 읽을 때, 타입의 key 사용을 허용하지 않는다. TypeScript가 처음이라면 아래 코드가 컴파일 에러를 만든다는 사실에 충격을 먹을 수도 있다. 조금 긴 에러 메세지는 다음과 같다. 해석조차도 그리 쉬운 편이 아니다. Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type ’{ foo: string; }‘. No index signature with a parameter of type ‘string’ was found on type…","fields":{"slug":"/2020/12/01/index-signatures-in-typescript/"},"frontmatter":{"date":"December 01, 2020","title":"TypeScript에서 string key로 객체에 접근하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz42RzU7CQBSFeS3ewJ0LE9QILS3FggkIC0JKO22hQDudYfqPgItabRrLwvgQLnwG48M4sgQtJJPJnTnny5l7p1QH6M/FAHIph1dKwAL8n6d0eEXdDWCdy3FZ/SwrHxU55AE8FWYUJKjm2TDmN19g+30NlnWFwvgkWNAdQcMVyb0AL02YcbrLq4jTjsGcimoy1KInkmzdJA/T3H9+nT+mYfaG41zQCavYRclU5gDqzIM+jMSxI05+X0Hr9tTbI/dhKgtj0pp6dzOfU3Fz4oiG2zK8qmSxANFjUTIj2/do1bOX03XahVEfrbQoCbL3Adl0zJBK1FCU3J75DZ3cSCatqyPIa4uuFQ0W6579cGu4x3veTQ7T4dF993N2bQRp5mHPP5j4IgALx2iIAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/d7fb0f787b366905b72b6e5dd692fc3c/3891b/thumbnail.png","srcSet":"/static/d7fb0f787b366905b72b6e5dd692fc3c/95f17/thumbnail.png 150w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/37d5a/thumbnail.png 300w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"블로그에 Category 기능을 추가하려 한다. 최종 목표는 두 개의 페이지를 만든느 것이디ㅏ. 모든 카테고리 이름, 카테고리당 포스트 갯수를 보여주는  페이지, 그리고 각 카테고리에 해당하는 포스트의 목록을 보여주는  페이지이다. 삽질한 것을 모두 기록하기는 어려우나, 새롭게 삽질을 시작하시려는 분들에게 조금이나마 도움이 될까 싶어 그 과정을 최대한 자세히 기록 하려고 한다. 는 단독의 Page이다. 그래서 를 구현하면 된다. 하지만 이와는 다르게 는 카테고리 종류 갯수 만큼의 페이지가 만들어 지며 빌드 타임에 Page들이 유동적으로 생성되어야 한다. 따라서 각 Page를 찍어낼 때 사용하는 Template 하나 가 필요하다. 완성된 /categories 페이지 완성된  페이지는 다음과 같다. 아직 스타일링은 되지 않았지만, 카테고리 목록과 포스트의 갯수를 표시해 준다. 카테고리 중 하나를 클릭하면  페이지로 이동한다.  완성된 /categories…","fields":{"slug":"/2020/11/27/add-categories-to-gatsby/"},"frontmatter":{"date":"November 27, 2020","title":"Gatsby Blog에 Category를 추가하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1om/G2fYp5ybPv9Q7/Vxi/gErn80OQUTZvMUndnt46q6gxB3Bidvjc/f4x++09ttCWDPQZqeQbU6h2618t0CQhfcmoMudQrbbBRDSDPSeT9weIIrNOZBXfSy16HBc7gHP6F2+8XuBUgRt3uIavsMtcqdz6DbvmF0ekTtcw7aDRCJ2AKWICm0IsvHbArQN4lo7bEkFAEqVBldglBBJAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/ff31aa8544ba3af4864008283bdaedd7/3891b/thumbnail.png","srcSet":"/static/ff31aa8544ba3af4864008283bdaedd7/95f17/thumbnail.png 150w,\n/static/ff31aa8544ba3af4864008283bdaedd7/37d5a/thumbnail.png 300w,\n/static/ff31aa8544ba3af4864008283bdaedd7/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"9.1. ECMAScript 6 표준 2015년 6월에 발표된 ECMAScript 6(ES6)은 ECMAScript 2015라고도 불린다. ES6과 ES 2015가 같기 때문에 헷갈리는 경우가 있다. 기존의 표준에 추가적인 기능들과 조금 더 나은 프로그래밍 언어의 모습을 얹어 놓았다. 개인적으로는 vue.js 2를 이용해서 개발할때 필요하므로 자세히 정리한다. 9.1.1. 변수, 상수 선언 키워드(let, const) const는 이전에 없었던 ‘상수’를 선언하는 기능이다 같은 변수를 const로 선언 후 다시 정의 하면 에러가 발생한다. “let은 “변수”를 선언하는데 var와는 조금 다르다.” var 와 다른 점은 다음 두가지이다. 중복 선언이 불가능하다. 다른 언어 처럼 중괄호를 이용한 블록 스코프 개념을 가지고 있다. 9.1.2. 함수 화살표 표현식 ES…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-9/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 9. JavaScript 표준","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"8.1. JavaScript 코딩 스타일 8.1.1. 변수 이름 표기법 Javascript에서는 camel case 표기법이 좋다.  처럼 DOM을 다루는 API들이 이미 채택하고 있기 때문이다. 여기에 다음과 같이 변수 타입을 나타내는 헝가리안 표기법을 더하는 것도 좋다. 8.1.2. 공백과 탭 공백을 선호하는 추세로 바뀌고 있으나, 탭은 1바이트라는 장점을 가지고 있다. 이 책에서는 4칸이 가독성이 더 좋다고 했다. 8.1.3. 중괄호를 여는 위치 중괄호는 줄바꿈하지 않는 것이 좋고, 줄바꿈을 한다면 오동작을 주의해야 한다. Javascript는 세미콜론 사용에 대한 규칙을 느슨하게 적용하는데,  다음 줄에 결과를 주더라도 으로 만들어 버리기 때문이다. 8.1.4. strict mode ECMAScript 5가 권장하는 방법이다. 파일이나 함수에 추가함으로서 설정 가능하다. strict 모드에서 제한 되는 내용은 다음과 같다. scope 내부에서 var 없이 global…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-8/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 8. Javascript 코딩과 개발 환경","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"7.1.  태그위치와 레이지 로드  태그위치 는 block mode로 작동한다. script가 다 실행 될때까지 화면이 렌더링 되지 않는다. 그 이유는 로 html을 쓸 수도 있기 때문이라 한다. 따라서  태그는 html 문서의 가장 아래 쪽에 위치하는 것이 좋다. Lazy Load For Script File 위와 같은 blocking현상을 막기 위해서 lazy load를 구현하는 것이다. lazy load는 와 를 이용해서 다음과 같이 구현한다.  를 이용할 수 있지만, 이 방식은 다수의 이벤트 핸들러를 등록하지 못하므로 기존에 등록되어 있던 것을 다 덮어 써버릴 염려가 있다. Lazy Load For Image File…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-7/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 7. JavaScript 성능과 사용자 경험 개선","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"6.1. 단일 스레드 환경 브라우저 환경의 가장 큰 특징은 single thread 방식이라는 점이다. JavaScript 런타임은 처리해야 하는 요청을 순차적으로 처리하기 위해서 Queue(event queue/task queue, 이 책에서는 스레드 큐라는 용어를 사용)를 사용한다. setTimeout(0)의 의미는? setTimeout(0)은 “즉시, 메세지큐에 새로운 메세지를 등록하라”는 뜻이다. 역시 이책은 명확하게 정의하지 않는다. 이곳과 이곳 참고하여 setTimeout을 정의하면 다음과 같다. setTimeout(func,n)은 “n밀리초 후에 func를 큐에 등록하라”는 뜻이다. 이렇게 하면 등록 전담 스레드가 있어야 할 것 같지만 정확한 구현은 알 수 없다. 적어도 메세지를 즉시 큐에 등록하고 n…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-6/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 6. 브라우저 환경에서의 JavaScript","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"이 책에서는 자주 볼 수있는 유용한 패턴을 몇가지 소개하고 있다. 5.2. 모듈 패턴 소스를 모듈 단위로 관리하기 위해서 쓰이는 패턴이다. 대표적인 예로 jQuery의 를 들 수 있다. 위와 같이  에 등록하는 방법, 아래와 같이 리턴을 받아서 할당하는 방법이 있다. 5.2. 이벤트 델리게이션 패턴 이 책에서는 정의를 제대로 내리지 않고 유용한 상황을 먼저 설명하고 있다. 아래는 내가 정의한 이벤트 델리게이션이다. 이벤트 델리게이션 패턴이란 다수의 element에 각각에 event handler를 할당하는 것이 아니라, 그 것을 감싸는 부모 element에 하나의 event handler만 할당하여 처리하는 방식이다. 이 때, 조건문을 통해서 각 element…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-5/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 5. 디자인 패턴 실용","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"4.1. 프로토타입을 통한 객체지향 4.1.1. 프로토타입의 정의 프로토타입이란 Javascript가 제공하는 객체 지향을 지원하기 위한 방법이다. Java의 상속과는 다르게 동적으로 부모 객체의 수정이 가능하다. 4.1.2. JavaScript와 자바의 객체 생성 비교 자바와 비슷하지만 JavaScript는 function으로 선언한다. 단, ECMAScript 6에서는 class 키워드가 추가되었다. 4.1.3. this의 이해 JavaScript에서의 this 가 무엇을 참조하는지는 “호출 방법” 에 따라서 변경이 된다. (스코프가 아님) 일반 함수 내에서의 this는 Window 객체를 참조한다. 맴버 함수 내에서의 this는 해당 함수를 포함하는 객체를 참조한다 call()과 apply()는 첫 번째 파라미터로 this…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-4/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 4. 프로토타입과 객체지향, 그리고 상속","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"3.1. JavaScript의 기본 형과 typeof javascript의 기본형 객체가 아닌 기본적인 키워드로 활용할 수 있는 기본형. number string boolean undefined null symbol typeof의 결과 목록 typeof는 문자열을 반환한다. “undefined” “boolean” “number” “string” “object” “function” “symbol” typeof의 결과 중 특이 한 것 “typeof null은 object이다.” 따라서, typeof를 이용해서 object인지 체크한 뒤 어떤 동작을 추가하려면, null 체크를 따로 먼저 해주는 것이 좋다. 3.2. new String(\"\"), String(\"\"), 그리고 \"\" Javascript의 문자열은 기본형(primitive)과 객체형 두가지 형태로 존재한다. new String()은 래퍼객체이고, \"\"과 String(\"\")은 기본형이다 String…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-3/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 3. JavaScript의 변수","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"2.1. 스코프란? 다른 프로그래밍 언어를 다루다가 JavaScript를 접하게 된 프로그래머가 반드시 한번 빠지게 되는 함정이 있다. JavaScript는 일반적인 프로그래밍 언어의 블록 스코프를 따르지 않는다. 2.1.1. 스코프의 생성 JavaScript에서 스코프를 생성하는 구문은 세가지가 있다. function을 이용한 스코프 생성 foo() 내부에서 선언된 변수를 외부에서 접근할 수 없다. catch을 이용한 스코프 생성 catch의 인자(이 경우에는 err)만 내부 스코프에 포함 된다. 선언된 변수(이 경우에는 test)는 외부 스코프에 포함된다. with을 이용한 스코프 생성 with 구문도 catch 처럼 인자가 내부 스코프에 포함 된다. 2.1.2. 스코프의 지속성 다른 언어와 다른 JavaScript…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-2/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 2. JavaScript의 스코프와 클로저","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"1.1. JavaScript의 어제와 오늘  창을 띄워 가며 디버깅 하던 시절이 있었다. 문법에러를 잡아 주지 않았기에 디버깅도 어려웠다. 지금은 다양한 디버깅 툴과 IDE 등의 등장으로 개발 환경이 확연히 달라졌다. JavaScript와 자바와의 관계는 햄과 햄버거의 관계이다 그럴듯한 비유이다. 둘의 이름은 공통된 부분이 있지만, 그닥 관계있는 음식은 아니다. 자바와 JavaScript는 무관하다고 하다고 말할 수 있을 정도로 전혀 관련이 없다. 역사적으로는 Netscape가 개발한 Livescript를 Sun Microsystems가 협업하면서 전략적으로 이름을 Javascript로 바꾼 것이다. 1.2. 웹 개발 방법론의 변화 2000년 이전의 웹 HTML 파일로 제공하는 텍스트 정보가 주를 이루었다. 또한 대부분 정적인 정보를 제공하는 웹페이지가 주를 이루었다. 포털이나 이메일 처럼 동적인 페이지를 생성하는 서버는 Perl과 CGI(Common Gateway Interface…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-1/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 1. 웹과 JavaScript","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"속깊은 JavaScript는 2017년에 읽었던 JavaScript 책 중 하나였다. 개인적으로 궁금했던 부분을 많이 담고 있어서 구매 했고, 독서의 효과를 높이기 위해서 예제코드와 본문을 나의 언어로 바꾸어 정리하기로 마음 먹었다. 목표를 만들면 완독까지 가기가 더 쉬워지기 때문이다. 그리 두껍지 않은 책인데다가 최대한 요약 정리만 했음에도 꽤 많은 분량이다.  챕터별 링크 Chapter 1. 웹과 JavaScript Chapter 2. JavaScript의 스코프와 클로저 Chapter 3. JavaScript의 변수 Chapter 4. 프로토타입과 객체지향, 그리고 상속 Chapter 5. 디자인 패턴 실용 Chapter 6. 브라우저 환경에서의 JavaScript Chapter 7. JavaScript 성능과 사용자 경험 개선 Chapter 8. Javascript 코딩과 개발 환경 Chapter 9. JavaScript 표준","fields":{"slug":"/2020/11/26/deep-javascript/"},"frontmatter":{"date":"November 25, 2020","title":"속깊은 JavaScript 빠르게 읽기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"첫 블로그를 만들기 위해서 사용한 는 국내에서 만들어진 것이 아니기 때문에 당연히 한글 폰트가 설정되어 있지 않다. 윈도우 사용자라면 Serif 계열은 “바탕체”, Sans 계열은 “맑은 고딕”으로 출력되고 있다. 또한 영문의 경우에도 gatsby-starter-blog가 기본적으로 사용하고 있는 다소 무자비해 보이는 제목 폰트가 보는 자의 심기를 불편하게 한다. 빛의 속도로 삭제한 Typography Gatsby의 공식 문서에서는 Typography.js…","fields":{"slug":"/2020/11/25/change-font-in-gatsby/"},"frontmatter":{"date":"November 25, 2020","title":"Gatsby Blog에 구글 폰트를 입히기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABA0lEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1onfG2fap56fMv9Q7/Vxi/gErn80OQcT42X+LV/S20OSdAXHbAuO3xWbv9o/baeu72YGQzVtsg3doJ1+0zL1smH7JNOuyWdZlg7RLBumXtFMu2gTvdAjcglOzQ8AWm5CdSjl3bWofuTU9Cup67Fj/yL7ukW3tI+Xce1ahu4EKCDjbNmi7ZQAIWQUiGEBBIuMZGLZbHMEknGGP6mAIAgCL7wfdhjH3JwAAAABJRU5ErkJggg==","aspectRatio":2,"src":"/static/8d36820ea7730f21623909807cc1c373/3891b/thumbnail.png","srcSet":"/static/8d36820ea7730f21623909807cc1c373/95f17/thumbnail.png 150w,\n/static/8d36820ea7730f21623909807cc1c373/37d5a/thumbnail.png 300w,\n/static/8d36820ea7730f21623909807cc1c373/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"과거에 작성한 와 에 저장된 포스트를 가져오는 작업을 먼저 해보기로 결정했다.  블로그의 레이아웃을 잡아가는 과정에서 몇 개 이상의 컨텐트가 필요하다고 생각했기 때문이다. 문서 자체는 markdown 파일이기에 복사 후 조금 수정해 주면 문제가 없다. 하지만 slug 구성과 폴더의 구조 결정이 우선적으로 이루어져야했다. Slug가 무엇일까 이미 라는 단어에 이미 익숙한 사람들이 많을지 모르겠지만, 나에게는 새로운 용어 중 하나였다. wikipedia에서 문서를 찾았지만 역시 민달팽이에 대한 것이었고, url과 함께 검색한 결과로 Clean URL 문서를 찾을 수 있었다. 이 문서를 통해서 slug의 뜻과 유래를 알 수 있었다. slug는 URL의 한 부분으로 사람이 읽기 쉬운 키워드로 페이지를 구분하게 해주는 키워드이다. 특정 리소스 혹은 파일의 이름, 페이지의 제목 등이 될 수 있다. 사람들은 이 slug를 통해서 해당 컨텐트의 내용을 제목을 짐작할 수 있다.  slug…","fields":{"slug":"/2020/11/24/create-slug-in-gatsby/"},"frontmatter":{"date":"November 24, 2020","title":"Gatsby Blog의 Slug를 구성하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQUlEQVQoz5XRz0sCQRQHcP+tQPdH/oCQdmfGMY1WV01TozXDH+ShKDoEdQiioIsQRmaitbbzZtcOnbvkob+o1SAI3CT4HobhfZh57/lEDHMTQBChEKbcPXjV+OZLDFFiHafNKurLqvUPLGFYUhiOjdpN50QbhrElzO4FNM0C7FYo6ddQnCcS5kaKyZT7FZAIhNfYMuUS4Z7YlcG4fXj2fnHzcXo1uWx/nl9Pyo03rA+KNZarjBTtccHLqymb5sck6+g7vHnk1A/sQtXUig/R5K1MBiLmc7DbrYggoE79StLSyqxUt0s1SJX6SOtIuBdA7Ef+xgj8KsgEVB1yu9xojSut8daeSTN3QdIV1BcR257TdoeBMzxrsO0GM/Yd95/JzW4o1hHU5xnjf6yKEb2Xrw6NllNu2OuF+whtS+jJi33nC2l9CphkdircAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/92fc6d213b8d3c3090703b67d1dcd55f/3891b/thumbnail.png","srcSet":"/static/92fc6d213b8d3c3090703b67d1dcd55f/95f17/thumbnail.png 150w,\n/static/92fc6d213b8d3c3090703b67d1dcd55f/37d5a/thumbnail.png 300w,\n/static/92fc6d213b8d3c3090703b67d1dcd55f/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"이 포스트에 Gatsby blog를 점진적으로 개선하는 과정을 기록한다. 어떤 순서로 진행해야 가장 효율적인지는 잘 모르겠지만 해야할것이 많다는 점이 마음을 바쁘게 한다. Gatsby를 시작하는 이에게는 어떤 작업들이 있는지 참고할 수 있다는 점에서 도움이 될 수도 있을 것 같다. 개선해야할 아이템 완료 여부 관련 포스트 프로필 수정: 사진, 글귀 ✔️  폰트 바꾸기 ✔️ 🔗 카테고리 기능 추가 ✔️ 🔗 sitemap.xml, robot.txt 추가 ✔️  목차 기능 추가하기 ✔️ 🔗 코드하이라이트: 스타일 변경, line highlight 기능 ✔️  로고 만들기 ✔️  Thumbnail 기능 추가 ✔️  MUI를 이용한 레이아웃 적용 및 스타일링 ✔️  과거의 포스트들 정리하여 가져오기 🚧  페이징 기능 추가 ☹️  코드하이라이트: language type 표시 ☹️  검색 기능 추가 ☹️  about…","fields":{"slug":"/2020/11/23/progressively-improve-gatsby/"},"frontmatter":{"date":"November 23, 2020","title":"Gatsby Blog 점진적으로 개선하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1om/G2fap56fMv9Q7/VxS/gErn80OQcTZ7BO7PTh5h3/cNv/4bTHZu/3jd1r7bSGsGajTKWSbc+gOr+idnlG7vKJ3uUfscAje5hSy3S6AkGag9zxjdkdlHSxpOFHVdqqk8QQQhafv947dA5Qixs87ApP2hqftC0ndG5y8Nzhlj3/iHpewHYRthui38d8C9KQNDAHttMOWVABf3QgyGyHCyQAAAABJRU5ErkJggg==","aspectRatio":2,"src":"/static/51d21be36f9ecd694862c90ae1fdfc86/3891b/thumbnail.png","srcSet":"/static/51d21be36f9ecd694862c90ae1fdfc86/95f17/thumbnail.png 150w,\n/static/51d21be36f9ecd694862c90ae1fdfc86/37d5a/thumbnail.png 300w,\n/static/51d21be36f9ecd694862c90ae1fdfc86/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"Hexo와 Wordpress를 버린 이유 2017년, 밤낮으로 영어 공부에만 매진할 당시 신개념에 가까웠던 static page generator인 를 이용해 블로그를 만들었다. 포스팅을 위한 용도는 아니었고, 단지 매일 학습한 것을 기록하는 용도였다. 접근의 용이함, 검색 기능, 백엔드 없이 동작할 수 있다는 이점이 있어서 잘 사용하고 있었다. 하지만 곧 메모의 용도로 은 사용이 매우 번거롭다는 걸 깨달았다. 그리고 중요한 점은 공부한 것을 기록하는 목적으로의 블로그는 어울리지 않는다. 글의 양만 많아질 뿐… 최근까지는 NAS에 설치한  이용하고 있었다. Wordpress…","fields":{"slug":"/2020/11/22/new-beginnings/"},"frontmatter":{"date":"November 22, 2020","title":"Gatsby로 새롭게 시작하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/webp;base64,UklGRoQAAABXRUJQVlA4IHgAAABwBACdASoUAA0APtFUo0uoJKMhsAgBABoJaACdMoADECipDmXs9p383b+eAAD+jTrur+s8dgPDdmmkMFnDFt3OKoRxD1mI7ILnstHE9L7QRgSND/LE8bhP3gziHMsmyGIHFC6SstdrExCQ+qXF1pZhvfWbnvgAAAA=","aspectRatio":1.5,"src":"/static/c1348f8110c39e66e68d92562f87c3a1/fc91b/time-for-a-change-897441_960_720.webp","srcSet":"/static/c1348f8110c39e66e68d92562f87c3a1/d9b14/time-for-a-change-897441_960_720.webp 150w,\n/static/c1348f8110c39e66e68d92562f87c3a1/0bc1d/time-for-a-change-897441_960_720.webp 300w,\n/static/c1348f8110c39e66e68d92562f87c3a1/fc91b/time-for-a-change-897441_960_720.webp 600w,\n/static/c1348f8110c39e66e68d92562f87c3a1/ae199/time-for-a-change-897441_960_720.webp 900w,\n/static/c1348f8110c39e66e68d92562f87c3a1/fcc10/time-for-a-change-897441_960_720.webp 960w","sizes":"(max-width: 600px) 100vw, 600px"}}}}}]}},"pageContext":{}},"staticQueryHashes":["2841359383","2911494500","3200528885"]}