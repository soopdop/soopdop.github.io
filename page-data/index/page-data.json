{
    "componentChunkName": "component---src-gatsby-theme-advanced-templates-feed-index-tsx",
    "path": "/",
    "result": {"pageContext":{"pageCount":4,"pageIndex":0,"feedType":"index","feedPageMeta":{"current":0,"next":1,"nextCount":5,"posts":[{"title":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","description":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLklEQVQoz42Sy07CQBSGeS3ewI0a5U5tmSlFY1C00gBlemaKpDdmChguMWwqKol04VO48BmMD2PiykCTmvzL78t/cvJnVBZiKvZTo5MSmVesOaLJgMrCDKYCAf+bGog6+MckytLPrPVRJAsVgh0GAcdUJMiKxTXqHXQjdfUF8XcFlsgKEIh/yZo91pgomtMcPDf8DbanKuWYpcmYcpkEbPE0XseT9XaxiWevW3f1Mt+88+hNs8c1a5TSjIjf8mZt8Vi3fA2Ci8HkbrRsOg/pZ6ssLOqQu+5LPTffIofnutR1ql2n3B6ky5gK2fQKN+Ss51SN+5IO+aveUeO23KaYhekPQ1QoJDhtdk4ujUKLSJ1h2bClznC/JpMwEuCYhQrxZdNT+r5surLp4l96ZyQ/qgIcQXkGWlAAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/1586a/thumbnail.png","srcSet":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/e3f2d/thumbnail.png 100w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/350f0/thumbnail.png 200w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/1586a/thumbnail.png 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[{"srcSet":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/4fb70/thumbnail.avif 100w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/8faf9/thumbnail.avif 200w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/96ea7/thumbnail.avif 400w","type":"image/avif","sizes":"(min-width: 400px) 400px, 100vw"},{"srcSet":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/9341e/thumbnail.webp 100w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/b7114/thumbnail.webp 200w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/bb5e7/thumbnail.webp 400w","type":"image/webp","sizes":"(min-width: 400px) 400px, 100vw"}]},"width":400,"height":200},"coverImageAlt":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","datePublished":"2020-12-13T00:00:00.000Z","dateModified":"2020-12-13T00:00:00.000Z","category":"TypeScript","tags":[],"excerpt":"JavaScript, TypeScript 그리고 Duck Typing에 대해서 구글링하면 많은 양의 검색 결과물을 볼 수 있다. 하지만 적절한 설명 없이 부정확한 용어를 혼용하기도 하고 (동적 타이핑, 다형성 등), 특히 Dynamic Programming Languages와 Dynamically Typed Languages를 동의어로 여기는 등 명확함이 떨어지거나 아예 틀린 설명을 길게 늘어 놓은 글들도 많이 확인 할 수 있었다. 이 포스트에서는 필요한 용어들만 사용해 TypeScript의 Typing 방식과 Duck Typing에 대해서 쉽게 설명한다. TypeScript에서는 구조가 같으면 할당 가능하다 Java, C# 개발자에게 다음과 같은 코드를 보여주면 매우 기겁하면서 도망을 가려고 할 것이다. Java를 기준으로  b 는 명백하게 타입  ClassB 로 부터 만들어진 객체이며 타입  ClassA 의 인스턴스를 할당할 수 없다. 하지만 이 것이 놀랍게도 TypeScript…","timeToRead":3,"slug":"/2020/12/09/duck-typing/","route":"/2020/12/09/duck-typing/","pathName":"2020/12/09/duck-typing/","url":"https://soopdop.github.io/2020/12/09/duck-typing/"},{"title":"Gatsby Blog 용 Animated SVG 로고 만들기","description":"Gatsby Blog 용 Animated SVG 로고 만들기","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABA0lEQVQoz2OwD9yKFdkGbHUL2eoass02YCsuNQzYdQZu9Q7a3Bi3oSBglaP/ZhI0OwRutfTbEhi8cW7ZjuaYta6Bm+2I12wXsNUvbpdL6Lbw8A3RsZsdg7fZ+m9xIEazXcBW59DtdV0n+mee65h6YfL8K70zzifmH7Dy2ewQRJTNW/zidgQmbveN2RgUtyImc0tg4m4bvy1EaXYM2mbmtTk8edGK1XvOnr0Qn7Xc1GOLYzBxfnYK3mbstrG+fcuH90////8za/5BfadVziE7iAvtoC3WftuDE5ZcvHD21Okz5XWLzT3XOQZvJzae7QO32fmt9QydY+21wMpnrX3gNqxRBQAWYQyi8BnxxgAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/fd44ab446f102955cb285d61692c532d/1586a/thumbnail.png","srcSet":"/static/fd44ab446f102955cb285d61692c532d/e3f2d/thumbnail.png 100w,\n/static/fd44ab446f102955cb285d61692c532d/350f0/thumbnail.png 200w,\n/static/fd44ab446f102955cb285d61692c532d/1586a/thumbnail.png 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[{"srcSet":"/static/fd44ab446f102955cb285d61692c532d/4fb70/thumbnail.avif 100w,\n/static/fd44ab446f102955cb285d61692c532d/8faf9/thumbnail.avif 200w,\n/static/fd44ab446f102955cb285d61692c532d/96ea7/thumbnail.avif 400w","type":"image/avif","sizes":"(min-width: 400px) 400px, 100vw"},{"srcSet":"/static/fd44ab446f102955cb285d61692c532d/9341e/thumbnail.webp 100w,\n/static/fd44ab446f102955cb285d61692c532d/b7114/thumbnail.webp 200w,\n/static/fd44ab446f102955cb285d61692c532d/bb5e7/thumbnail.webp 400w","type":"image/webp","sizes":"(min-width: 400px) 400px, 100vw"}]},"width":400,"height":200},"coverImageAlt":"Gatsby Blog 용 Animated SVG 로고 만들기","datePublished":"2020-12-08T00:00:00.000Z","dateModified":"2020-12-08T00:00:00.000Z","category":"Tutorials","tags":[],"excerpt":"개인 블로그에 로고가 왜 필요할까? 처음 블로그를 만들 당시는 필요 없을 것이라 생각했다. 하지만 로고는  Favicon 과 무관하지 않았기에 어쩔 수 없이 만들어야 하는 것이었다. 큰 사이즈의 로고를 만들면 그 것을 리사이징하여 Favicon에 사용할 수 있기 때문이다. 이 포스트에서는 Animated SVG 로고를 만들고 블로그 첫 화면에 적용하는 과정을 설명한다. Favicon에 사용할 로고가 필요한 이유 모바일 기기 세상이 도래하면서 Favicon이 쓰임이 과거와는 많이 달라졌다. 데스크탑의 IE가 주류였던 시절에는 웹브라우저 상단의 탭에 아이콘을 표시하기 위해서  16x16 의 작은 크기의  favicon.ico 만 제공하면 됐다. 하지만 현재는 데스크탑 뿐만 아니라 모바일 기기에서도 바탕화면에 웹사이트의 바로가기를 생성하는 기능을 제공하고 있으며 디스플레이의 해상도가 높아지면서  16x1…","timeToRead":4,"slug":"/2020/12/08/create-svg-logo/","route":"/2020/12/08/create-svg-logo/","pathName":"/2020/12/08/create-svg-logo/","url":"https://soopdop.github.io/2020/12/08/create-svg-logo/"},{"title":"Gatsby Blog에 목차 추가하기","description":"Gatsby Blog에 목차 추가하기","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVQoz2OwD9yKFdkGbHUL2eoass02YCsuNQzYdQZu9Q7a3Bi3oSBglaP/ZhI0OwRutfTbEhi8cW7ZjuaYta6Bm+2I12wXsNUvbpdL6Lbw8A3RsZsdg7fZ+m9xIEazXcBW59DtdV0n+macbZ96fsr8S73TzyXlH7Dy2ewQRJzNvrHbQ1J2+sdvD4jfFpuzOyBhl43fFmI1OwVvy6k6Xlh3MqfqeHT2AaeQbXYBxPnZNmCLW8SOlv7znVMuNvWey60+7hG509Z/C7EB5hK2Pa/2eGHDyZya43F5B13Dd9gFbCE2nu0Dt1r7boYgG2x2QjQDAGrUCa+q3z2MAAAAAElFTkSuQmCC"},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/eec42787b5f023fb867a219b41e32841/1586a/thumbnail.png","srcSet":"/static/eec42787b5f023fb867a219b41e32841/e3f2d/thumbnail.png 100w,\n/static/eec42787b5f023fb867a219b41e32841/350f0/thumbnail.png 200w,\n/static/eec42787b5f023fb867a219b41e32841/1586a/thumbnail.png 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[{"srcSet":"/static/eec42787b5f023fb867a219b41e32841/4fb70/thumbnail.avif 100w,\n/static/eec42787b5f023fb867a219b41e32841/8faf9/thumbnail.avif 200w,\n/static/eec42787b5f023fb867a219b41e32841/96ea7/thumbnail.avif 400w","type":"image/avif","sizes":"(min-width: 400px) 400px, 100vw"},{"srcSet":"/static/eec42787b5f023fb867a219b41e32841/9341e/thumbnail.webp 100w,\n/static/eec42787b5f023fb867a219b41e32841/b7114/thumbnail.webp 200w,\n/static/eec42787b5f023fb867a219b41e32841/bb5e7/thumbnail.webp 400w","type":"image/webp","sizes":"(min-width: 400px) 400px, 100vw"}]},"width":400,"height":200},"coverImageAlt":"Gatsby Blog에 목차 추가하기","datePublished":"2020-12-03T00:00:00.000Z","dateModified":"2020-12-03T00:00:00.000Z","category":"Tutorials","tags":[],"excerpt":"이 포스트에서는 Table of Contents(목차) Component를 만들고 본문 우측 상단에 위치시키는 과정에 대해서 알아본다. TableOfContent 필드 확인 각 markdown 문서의 목차는 이미  gatsby-transformer-remark 플러그인에 의해서 HTML로 만들어져 있다. 이 플러그인은  gatsby-starter-blog 에 기본적으로 들어 있는 플러그인으로 markdown문서를 HTML 문서로 변환해주는 역할을 한다. GraphQL 콘솔에서 위와 같이 쿼리해보면 노드의 tableOfContents 필드에 HTML 이 들어 있는 것을 알 수 있다. 스타일은 적용되어 있지 않으며,  <a href='/slug/#header-title'>  형태의 링크까지 제공된다. 어떤 블로그에서는 결과물로써 HTML이 나오기 때문에 이 것을 활용하려면 파싱이 필요하다 한다. HTML이 아닌 데이터구조로 목차가 제공되는  mdx…","timeToRead":2,"slug":"/2020/12/03/add-table-of-content-gatsby/","route":"/2020/12/03/add-table-of-content-gatsby/","pathName":"2020/12/03/add-table-of-content-gatsby/","url":"https://soopdop.github.io/2020/12/03/add-table-of-content-gatsby/"},{"title":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","description":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBElEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka0M0zoxlYEQphDz1HaGmf3BzUmf8/SfVLto91UwTO9mmtZOlGaWqW0Ms/pjGmL/Z2v8qvfQ7ydJ87QOhhndKr0VOTXhSVWhYpMbGWZ2M08n5GyQb6e2ma2c579+mfvGlZ7bN3ns2Oyybmnyjg1WqxYwTG5lmt5JwGbeGd0iM3tFZvWKzewWn9UjOLNHcd4k3hndDJgux+KYGZ0MM7sZprYxTG2HohldIETYz1PaGOZPYpg3kWFKG/uMbpYZXQxT2hjn9DMsmAySIqB5ajvDrF6G2X0MU9uZpncyTu8EiczuBaGpxDibaAQAGYbn6laPuagAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/1586a/thumbnail1.png","srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/e3f2d/thumbnail1.png 100w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/350f0/thumbnail1.png 200w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/1586a/thumbnail1.png 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[{"srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/4fb70/thumbnail1.avif 100w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/8faf9/thumbnail1.avif 200w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/96ea7/thumbnail1.avif 400w","type":"image/avif","sizes":"(min-width: 400px) 400px, 100vw"},{"srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/9341e/thumbnail1.webp 100w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/b7114/thumbnail1.webp 200w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/bb5e7/thumbnail1.webp 400w","type":"image/webp","sizes":"(min-width: 400px) 400px, 100vw"}]},"width":400,"height":200},"coverImageAlt":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","datePublished":"2020-12-02T00:00:00.000Z","dateModified":"2020-12-02T00:00:00.000Z","category":"JavaScript","tags":[],"excerpt":"JavaScript(ES6)에서  ...  기호는 두 가지로 용법으로 쓰인다. Spread Operator와 Rest Parameter이다. 각각의 문법은 레퍼런스 문서에 상세하게 설명되어 있이며 이미 경험적으로 익숙해진 사람들에게는 그렇게 어렵지 않다. 하지만 처음 타입스크립트를 접한 사람들이 두 개의 용법이 섞인 복잡한 코드를 본다면 적잖게 혼란스러울 수 있다. 대부분 따로 설명되어 있는 이 두 개의 용법을 하나로 묶어서 쉽게 설명하는 것이 이 포스트의 목적이다. 만만한 Spread부터 파헤치자 spread operator는 iterable 객체를 함수의 인자 혹은 배열 literal의 요소로 확장한다. 조금 더 쉽게 말하면 배열과 같은 복수개의 데이터를 가진 데이터형을  , , , 으로 구분되는 여러개의 요소로 펼치는(spread) 곳에 사용한다는 것이다. 함수의 인자로 펼치기 대표적인 사용법 중 하나는 Iterable…","timeToRead":2,"slug":"/2020/12/02/rest-and-spread-in-javascript/","route":"/2020/12/02/rest-and-spread-in-javascript/","pathName":"/2020/12/02/rest-and-spread-in-javascript/","url":"https://soopdop.github.io/2020/12/02/rest-and-spread-in-javascript/"},{"title":"TypeScript에서 string key로 객체에 접근하기","description":"TypeScript에서 string key로 객체에 접근하기","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABK0lEQVQoz42RTW6CQBSAvZY36K6LJrZNlQHEok38YWEMzgwgqDAzCChg0S6sLTHFRdNDdNEzND1Mo0ul2uTlLV7el+/9FHjMcoPD3jWMblAIsPtXT+G4BLBbxc4lXBW1ryL6LMFIxOS/MIeYpNkXvZW4/Mbbn1s85xHh8/w5sGT4ku6W1OAKv9bIRjACUWOCfg4WNFaBRI+fvfU2WGdRms1e3sZPabR5d1eZZHgA0VNmgKiAWXMcKiSWB75s7qZQSNwYTg/IQxggKg28+nD6MJoJmlszfdkK6ta0rDoAs5rpnzJzkLZZ0qHz4SJtkVhhiR6vw81H11s27ajNEg7SU+bGaFY1vDvVBoiW+0TUJy0n7k4WHfp4bwXnd95fzhW0Xd5/jlb6hIP0eOdfmPgiAPjypsMAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/d7fb0f787b366905b72b6e5dd692fc3c/1586a/thumbnail.png","srcSet":"/static/d7fb0f787b366905b72b6e5dd692fc3c/e3f2d/thumbnail.png 100w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/350f0/thumbnail.png 200w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/1586a/thumbnail.png 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[{"srcSet":"/static/d7fb0f787b366905b72b6e5dd692fc3c/4fb70/thumbnail.avif 100w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/8faf9/thumbnail.avif 200w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/96ea7/thumbnail.avif 400w","type":"image/avif","sizes":"(min-width: 400px) 400px, 100vw"},{"srcSet":"/static/d7fb0f787b366905b72b6e5dd692fc3c/9341e/thumbnail.webp 100w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/b7114/thumbnail.webp 200w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/bb5e7/thumbnail.webp 400w","type":"image/webp","sizes":"(min-width: 400px) 400px, 100vw"}]},"width":400,"height":200},"coverImageAlt":"TypeScript에서 string key로 객체에 접근하기","datePublished":"2020-12-01T00:00:00.000Z","dateModified":"2020-12-01T00:00:00.000Z","category":"TypeScript","tags":[],"excerpt":"TypeScript는 JavaScript의 관점에서 벗어나지 못한 상태로 접했을 때 매우 이상하게 느껴질 때가 있다. 이 포스트에서는 그런한 점 중 하나였던 index signatures에 대해서 이해하기 쉽게 설명하고자 한다. TypeScript에서는 안되는 것이 있다? TypeScript는 기본적으로 객체의 프로퍼티를 읽을 때,  string 타입의 key 사용을 허용하지 않는다. TypeScript가 처음이라면 아래 코드가 컴파일 에러를 만든다는 사실에 충격을 먹을 수도 있다. 조금 긴 에러 메세지는 다음과 같다. 해석조차도 그리 쉬운 편이 아니다. Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ foo: string; }'. No index signature with a parameter of type 'string' was found on…","timeToRead":3,"slug":"/2020/12/01/index-signatures-in-typescript/","route":"/2020/12/01/index-signatures-in-typescript/","pathName":"/2020/12/01/index-signatures-in-typescript/","url":"https://soopdop.github.io/2020/12/01/index-signatures-in-typescript/"}]}}},
    "staticQueryHashes": ["3661114550","546898263"]}