{"componentChunkName":"component---src-templates-post-list-template-tsx","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Harry Park's Blog"}},"allMarkdownRemark":{"totalCount":20,"nodes":[{"excerpt":"JavaScript, TypeScript 그리고 Duck Typing에 대해서 구글링하면 많은 양의 검색 결과물을 볼 수 있다. 하지만 적절한 설명 없이 부정확한 용어를 혼용하기도 하고 (동적 타이핑, 다형성 등), 특히 Dynamic Programming Languages와 Dynamically Typed Languages를 동의어로 여기는 등 명확함이 떨어지거나 아예 틀린 설명을 길게 늘어 놓은 글들도 많이 확인 할 수 있었다. 이 포스트에서는 필요한 용어들만 사용해 TypeScript의 Typing 방식과 Duck Typing에 대해서 쉽게 설명한다. TypeScript에서는 구조가 같으면 할당 가능하다 Java, C# 개발자에게 다음과 같은 코드를 보여주면 매우 기겁하면서 도망을 가려고 할 것이다. Java를 기준으로 는 명백하게 타입 로 부터 만들어진 객체이며 타입 의 인스턴스를 할당할 수 없다. 하지만 이 것이 놀랍게도 TypeScript…","fields":{"slug":"/2020/12/09/duck-typing/"},"frontmatter":{"date":"December 13, 2020","title":"TypeScript와 Duck Typing의 관계 쉽게 설명하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKUlEQVQoz2NIqu9NrOvBRPF1/eHVUyJrpiTUYVcA1MgApBJqu5FRfG1Pcm2Hf/V8y7oTljVHwqqnJtV2oqkBIqBGLJrjarpT6to9yucnzbpVu+pOZO20hBqg5h6iNKc09KXU94RVTgiuXZTasTSxYUJSXXdiPSHNiXXdsdWd9VMX9C1c1b9w5dSlqyYvWdk2a/GUpeu6568AGhpf00XA5oTqjrz2ycU9M5JrOlJqO9Mb+4u6pmW3TiTsbGAYhhXWBudWRVe0heRV+6YVRpe3RpW3RhQ3EtYM5MZWtofmV8dUtEaVNIUX1obkVPilFkQU1yXW9xIOsIS6nrjqzqDsssDMktC86uiy5oiSBiCJaQ0DlkQClKjvjavuADohrgpItgFRIlg1WiIBAKoCHEH/hULxAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/3891b/thumbnail.png","srcSet":"/static/9672e58728dc0ea8cb5c7f8243ed76e4/95f17/thumbnail.png 150w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/37d5a/thumbnail.png 300w,\n/static/9672e58728dc0ea8cb5c7f8243ed76e4/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"개인 블로그에 로고가 왜 필요할까? 처음 블로그를 만들 당시는 필요 없을 것이라 생각했다. 하지만 로고는 과 무관하지 않았기에 어쩔 수 없이 만들어야 하는 것이었다. 큰 사이즈의 로고를 만들면 그 것을 리사이징하여 Favicon에 사용할 수 있기 때문이다. 이 포스트에서는 Animated SVG 로고를 만들고 블로그 첫 화면에 적용하는 과정을 설명한다. Favicon에 사용할 로고가 필요한 이유 모바일 기기 세상이 도래하면서 Favicon이 쓰임이 과거와는 많이 달라졌다. 데스크탑의 IE가 주류였던 시절에는 웹브라우저 상단의 탭에 아이콘을 표시하기 위해서 의 작은 크기의 만 제공하면 됐다. 하지만 현재는 데스크탑 뿐만 아니라 모바일 기기에서도 바탕화면에 웹사이트의 바로가기를 생성하는 기능을 제공하고 있으며 디스플레이의 해상도가 높아지면서 으로는 더이상 괜찮은 퀄리티의 아이콘을 제공할 수 없게 되었다.  이에 따라 Favicon…","fields":{"slug":"/2020/12/08/create-svg-logo/"},"frontmatter":{"date":"December 08, 2020","title":"Gatsby Blog 용 Animated SVG 로고 만들기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/0lEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1on/muY6pFybPv9I743xi/gErn80OQUTZvMUvbkdg4nbfmI1BcStiMrcEJu628dtClGbHoG1mXpvDkxetWL3n7NkL8VnLTT22OAYT52en4G3Gbhvr27d8eP/0//8/s+Yf1Hda5Ryyg7jQDtpi7bc9OGHJxQtnT50+U1632NxznWPwdmLj2T5wm53fWs/QOdZeC6x81gK5WJUBABZhDKLDMDULAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/fd44ab446f102955cb285d61692c532d/3891b/thumbnail.png","srcSet":"/static/fd44ab446f102955cb285d61692c532d/95f17/thumbnail.png 150w,\n/static/fd44ab446f102955cb285d61692c532d/37d5a/thumbnail.png 300w,\n/static/fd44ab446f102955cb285d61692c532d/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"이 포스트에서는 Table of Contents(목차) Component를 만들고 본문 우측 상단에 위치시키는 과정에 대해서 알아본다. TableOfContent 필드 확인 각 markdown 문서의 목차는 이미 플러그인에 의해서 HTML로 만들어져 있다. 이 플러그인은 에 기본적으로 들어 있는 플러그인으로 markdown문서를 HTML 문서로 변환해주는 역할을 한다. GraphQL 콘솔에서 위와 같이 쿼리해보면 노드의 tableOfContents 필드에 HTML 이 들어 있는 것을 알 수 있다. 스타일은 적용되어 있지 않으며,  형태의 링크까지 제공된다. 어떤 블로그에서는 결과물로써 HTML이 나오기 때문에 이 것을 활용하려면 파싱이 필요하다 한다. HTML이 아닌 데이터구조로 목차가 제공되는 로의 전환을 고려하는 방법도 있다. 아마 특정 UI framework을 적용 했을 경우 제공되는 와 류의 Component…","fields":{"slug":"/2020/12/03/add-table-of-content-gatsby/"},"frontmatter":{"date":"December 03, 2020","title":"Gatsby Blog에 목차 추가하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7ElEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1om/G2fap56fMv9Q7/VxS/gErn80OQcTZ7Bu7PSRlp3/89oD4bbE5uwMSdtn4bSFWs1Pwtpyq44V1J4FkdPYBp5BtdgHE+dk2YItbxI6W/vOdUy429Z7LrT7uEbkT6G1iA8wlbHte7fHChpM5Ncfj8g66hu+wC9hCbDwDkbXvZgiywWYnBAEAatQJr+GXWmsAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/eec42787b5f023fb867a219b41e32841/3891b/thumbnail.png","srcSet":"/static/eec42787b5f023fb867a219b41e32841/95f17/thumbnail.png 150w,\n/static/eec42787b5f023fb867a219b41e32841/37d5a/thumbnail.png 300w,\n/static/eec42787b5f023fb867a219b41e32841/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"JavaScript(ES6)에서  기호는 두 가지로 용법으로 쓰인다. Spread Operator와 Rest Parameter이다. 각각의 문법은 레퍼런스 문서에 상세하게 설명되어 있이며 이미 경험적으로 익숙해진 사람들에게는 그렇게 어렵지 않다. 하지만 처음 타입스크립트를 접한 사람들이 두 개의 용법이 섞인 복잡한 코드를 본다면 적잖게 혼란스러울 수 있다. 대부분 따로 설명되어 있는 이 두 개의 용법을 하나로 묶어서 쉽게 설명하는 것이 이 포스트의 목적이다. 만만한 Spread부터 파헤치자 spread operator는 iterable 객체를 함수의 인자 혹은 배열 literal의 요소로 확장한다. 조금 더 쉽게 말하면 배열과 같은 복수개의 데이터를 가진 데이터형을 으로 구분되는 여러개의 요소로 펼치는(spread) 곳에 사용한다는 것이다. 함수의 인자로 펼치기 대표적인 사용법 중 하나는 Iterable…","fields":{"slug":"/2020/12/02/rest-and-spread-in-javascript/"},"frontmatter":{"date":"December 02, 2020","title":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+Cobp3UzT2onSzDK1jWFWf0xD7P9sjV/1Hvr9JGkGkjO6VXorcmrCk6pCxSY3MszsZp5OyNkg305tM1s5z3/9MveNKz23b/LYsdll3dLkHRusVi1gmNzKNL2TgM28M7pFZvaKzOoVm9ktPqtHcGaP4rxJQEEGTJdjccyMTqA7gU5gAIYcBM3oAiHCfp7SxjB/EsO8iUAG+4xuFqCeKW2Mc/oZFkwGSRHQDLRnVi/D7D4gA+hDRqAngSKze0FoKjHOJhoBABmG5+pH0J5FAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png","srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/95f17/thumbnail1.png 150w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/37d5a/thumbnail1.png 300w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"TypeScript는 JavaScript의 관점에서 벗어나지 못한 상태로 접했을 때 매우 이상하게 느껴질 때가 있다. 이 포스트에서는 그런한 점 중 하나였던 index signatures에 대해서 이해하기 쉽게 설명하고자 한다. TypeScript에서는 안되는 것이 있다? TypeScript는 기본적으로 객체의 프로퍼티를 읽을 때, 타입의 key 사용을 허용하지 않는다. TypeScript가 처음이라면 아래 코드가 컴파일 에러를 만든다는 사실에 충격을 먹을 수도 있다. 조금 긴 에러 메세지는 다음과 같다. 해석조차도 그리 쉬운 편이 아니다. Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type ’{ foo: string; }‘. No index signature with a parameter of type ‘string’ was found on type…","fields":{"slug":"/2020/12/01/index-signatures-in-typescript/"},"frontmatter":{"date":"December 01, 2020","title":"TypeScript에서 string key로 객체에 접근하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJklEQVQoz42RzU7CQBSFeS3ewJ0LE9QILS3FggkIC0JKO22hQDudYfqPgItabRrLwvgQLnwG48M4sgQtJJPJnTnny5l7p1QH6M/FAHIph1dKwAL8n6d0eEXdDWCdy3FZ/SwrHxU55AE8FWYUJKjm2TDmN19g+30NlnWFwvgkWNAdQcMVyb0AL02YcbrLq4jTjsGcimoy1KInkmzdJA/T3H9+nT+mYfaG41zQCavYRclU5gDqzIM+jMSxI05+X0Hr9tTbI/dhKgtj0pp6dzOfU3Fz4oiG2zK8qmSxANFjUTIj2/do1bOX03XahVEfrbQoCbL3Adl0zJBK1FCU3J75DZ3cSCatqyPIa4uuFQ0W6579cGu4x3veTQ7T4dF993N2bQRp5mHPP5j4IgALx2iIAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/d7fb0f787b366905b72b6e5dd692fc3c/3891b/thumbnail.png","srcSet":"/static/d7fb0f787b366905b72b6e5dd692fc3c/95f17/thumbnail.png 150w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/37d5a/thumbnail.png 300w,\n/static/d7fb0f787b366905b72b6e5dd692fc3c/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"블로그에 Category 기능을 추가하려 한다. 최종 목표는 두 개의 페이지를 만든느 것이디ㅏ. 모든 카테고리 이름, 카테고리당 포스트 갯수를 보여주는  페이지, 그리고 각 카테고리에 해당하는 포스트의 목록을 보여주는  페이지이다. 삽질한 것을 모두 기록하기는 어려우나, 새롭게 삽질을 시작하시려는 분들에게 조금이나마 도움이 될까 싶어 그 과정을 최대한 자세히 기록 하려고 한다. 는 단독의 Page이다. 그래서 를 구현하면 된다. 하지만 이와는 다르게 는 카테고리 종류 갯수 만큼의 페이지가 만들어 지며 빌드 타임에 Page들이 유동적으로 생성되어야 한다. 따라서 각 Page를 찍어낼 때 사용하는 Template 하나 가 필요하다. 완성된 /categories 페이지 완성된  페이지는 다음과 같다. 아직 스타일링은 되지 않았지만, 카테고리 목록과 포스트의 갯수를 표시해 준다. 카테고리 중 하나를 클릭하면  페이지로 이동한다.  완성된 /categories…","fields":{"slug":"/2020/11/27/add-categories-to-gatsby/"},"frontmatter":{"date":"November 27, 2020","title":"Gatsby Blog에 Category를 추가하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz2OwD9yKFdkGbHUL2eoasg3IwKWGAbvOwK3eQZsb4zYUBKxy9N9MgmaHwK2WflsCgzfOLdvRHLPWNXCzHfGa7QK2+sXtcgndFh6+ITp2s2PwNlv/LQ7EaAbqdA7dXtd1om/G2fYp5ybPv9Q7/Vxi/gErn80OQUTZvMUndnt46q6gxB3Bidvjc/f4x++09ttCWDPQZqeQbU6h2618t0CQhfcmoMudQrbbBRDSDPSeT9weIIrNOZBXfSy16HBc7gHP6F2+8XuBUgRt3uIavsMtcqdz6DbvmF0ekTtcw7aDRCJ2AKWICm0IsvHbArQN4lo7bEkFAEqVBldglBBJAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/ff31aa8544ba3af4864008283bdaedd7/3891b/thumbnail.png","srcSet":"/static/ff31aa8544ba3af4864008283bdaedd7/95f17/thumbnail.png 150w,\n/static/ff31aa8544ba3af4864008283bdaedd7/37d5a/thumbnail.png 300w,\n/static/ff31aa8544ba3af4864008283bdaedd7/3891b/thumbnail.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"9.1. ECMAScript 6 표준 2015년 6월에 발표된 ECMAScript 6(ES6)은 ECMAScript 2015라고도 불린다. ES6과 ES 2015가 같기 때문에 헷갈리는 경우가 있다. 기존의 표준에 추가적인 기능들과 조금 더 나은 프로그래밍 언어의 모습을 얹어 놓았다. 개인적으로는 vue.js 2를 이용해서 개발할때 필요하므로 자세히 정리한다. 9.1.1. 변수, 상수 선언 키워드(let, const) const는 이전에 없었던 ‘상수’를 선언하는 기능이다 같은 변수를 const로 선언 후 다시 정의 하면 에러가 발생한다. “let은 “변수”를 선언하는데 var와는 조금 다르다.” var 와 다른 점은 다음 두가지이다. 중복 선언이 불가능하다. 다른 언어 처럼 중괄호를 이용한 블록 스코프 개념을 가지고 있다. 9.1.2. 함수 화살표 표현식 ES…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-9/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 9. JavaScript 표준","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"8.1. JavaScript 코딩 스타일 8.1.1. 변수 이름 표기법 Javascript에서는 camel case 표기법이 좋다.  처럼 DOM을 다루는 API들이 이미 채택하고 있기 때문이다. 여기에 다음과 같이 변수 타입을 나타내는 헝가리안 표기법을 더하는 것도 좋다. 8.1.2. 공백과 탭 공백을 선호하는 추세로 바뀌고 있으나, 탭은 1바이트라는 장점을 가지고 있다. 이 책에서는 4칸이 가독성이 더 좋다고 했다. 8.1.3. 중괄호를 여는 위치 중괄호는 줄바꿈하지 않는 것이 좋고, 줄바꿈을 한다면 오동작을 주의해야 한다. Javascript는 세미콜론 사용에 대한 규칙을 느슨하게 적용하는데,  다음 줄에 결과를 주더라도 으로 만들어 버리기 때문이다. 8.1.4. strict mode ECMAScript 5가 권장하는 방법이다. 파일이나 함수에 추가함으로서 설정 가능하다. strict 모드에서 제한 되는 내용은 다음과 같다. scope 내부에서 var 없이 global…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-8/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 8. Javascript 코딩과 개발 환경","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"7.1.  태그위치와 레이지 로드  태그위치 는 block mode로 작동한다. script가 다 실행 될때까지 화면이 렌더링 되지 않는다. 그 이유는 로 html을 쓸 수도 있기 때문이라 한다. 따라서  태그는 html 문서의 가장 아래 쪽에 위치하는 것이 좋다. Lazy Load For Script File 위와 같은 blocking현상을 막기 위해서 lazy load를 구현하는 것이다. lazy load는 와 를 이용해서 다음과 같이 구현한다.  를 이용할 수 있지만, 이 방식은 다수의 이벤트 핸들러를 등록하지 못하므로 기존에 등록되어 있던 것을 다 덮어 써버릴 염려가 있다. Lazy Load For Image File…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-7/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 7. JavaScript 성능과 사용자 경험 개선","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}},{"excerpt":"6.1. 단일 스레드 환경 브라우저 환경의 가장 큰 특징은 single thread 방식이라는 점이다. JavaScript 런타임은 처리해야 하는 요청을 순차적으로 처리하기 위해서 Queue(event queue/task queue, 이 책에서는 스레드 큐라는 용어를 사용)를 사용한다. setTimeout(0)의 의미는? setTimeout(0)은 “즉시, 메세지큐에 새로운 메세지를 등록하라”는 뜻이다. 역시 이책은 명확하게 정의하지 않는다. 이곳과 이곳 참고하여 setTimeout을 정의하면 다음과 같다. setTimeout(func,n)은 “n밀리초 후에 func를 큐에 등록하라”는 뜻이다. 이렇게 하면 등록 전담 스레드가 있어야 할 것 같지만 정확한 구현은 알 수 없다. 적어도 메세지를 즉시 큐에 등록하고 n…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-6/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 6. 브라우저 환경에서의 JavaScript","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}]}},"pageContext":{"limit":10,"skip":0,"numPages":2,"currentPage":1}},"staticQueryHashes":["2841359383","2911494500","3200528885"]}