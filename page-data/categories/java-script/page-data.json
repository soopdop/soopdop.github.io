{"componentChunkName":"component---src-templates-category-tsx","path":"/categories/java-script/","result":{"data":{"site":{"siteMetadata":{"title":"Harry Park's Blog"}},"allMarkdownRemark":{"totalCount":11,"edges":[{"node":{"excerpt":"JavaScript(ES6)에서  기호는 두 가지로 용법으로 쓰인다. Spread Operator와 Rest Parameter이다. 각각의 문법은 레퍼런스 문서에 상세하게 설명되어 있이며 이미 경험적으로 익숙해진 사람들에게는 크게 어렵지 않다. 하지만 처음 타입스크립트를 접한 사람들은 두 개의 용법이 섞인 복잡한 코드를 본다면 꽤 혼란스러울 수 있다. 대부분의 레퍼런스 문서는 각각의 기능에 대해 군더더기 없이 설명된 훌륭한 문서이지만, 위와 같이 여러 문법이 혼용되는 상황에서의 어려움을 다루지는 않는다. 이 포스트에서는 두 개의 용법이 혼란을 주는 포인트를 알아보고 하나로 묶어서 쉽게 설명하고자 한다. 만만치 않은 예제 아래의 예제에게 아무런 거부감을 느끼지 못하는 사람은 이 포스트를 읽을 필요가 없다. 만만한 Spread부터 파헤치자 spread operator는 iterable 객체를 함수의 인자 혹은 배열 literal…","fields":{"slug":"/2020/12/02/rest-and-spread-in-javascript/"},"frontmatter":{"date":"December 02, 2020","title":"JavaScript(ES6)의 Spread 와 Rest 쉽게 설명하기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+Cobp3UzT2onSzDK1jWFWf0xD7P9sjV/1Hvr9JGkGkjO6VXorcmrCk6pCxSY3MszsZp5OyNkg305tM1s5z3/9MveNKz23b/LYsdll3dLkHRusVi1gmNzKNL2TgM28M7pFZvaKzOoVm9ktPqtHcGaP4rxJQEEGTJdjccyMTqA7gU5gAIYcBM3oAiHCfp7SxjB/EsO8iUAG+4xuFqCeKW2Mc/oZFkwGSRHQDLRnVi/D7D4gA+hDRqAngSKze0FoKjHOJhoBABmG5+pH0J5FAAAAAElFTkSuQmCC","aspectRatio":2,"src":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png","srcSet":"/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/95f17/thumbnail1.png 150w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/37d5a/thumbnail1.png 300w,\n/static/1995ebe98c7822a7fa3bed8c3bfb2ea3/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"9.1. ECMAScript 6 표준 2015년 6월에 발표된 ECMAScript 6(ES6)은 ECMAScript 2015라고도 불린다. ES6과 ES 2015가 같기 때문에 헷갈리는 경우가 있다. 기존의 표준에 추가적인 기능들과 조금 더 나은 프로그래밍 언어의 모습을 얹어 놓았다. 개인적으로는 vue.js 2를 이용해서 개발할때 필요하므로 자세히 정리한다. 9.1.1. 변수, 상수 선언 키워드(let, const) const는 이전에 없었던 ‘상수’를 선언하는 기능이다 같은 변수를 const로 선언 후 다시 정의 하면 에러가 발생한다. “let은 “변수”를 선언하는데 var와는 조금 다르다.” var 와 다른 점은 다음 두가지이다. 중복 선언이 불가능하다. 다른 언어 처럼 중괄호를 이용한 블록 스코프 개념을 가지고 있다. 9.1.2. 함수 화살표 표현식 ES…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-9/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 9. JavaScript 표준","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"8.1. JavaScript 코딩 스타일 8.1.1. 변수 이름 표기법 Javascript에서는 camel case 표기법이 좋다.  처럼 DOM을 다루는 API들이 이미 채택하고 있기 때문이다. 여기에 다음과 같이 변수 타입을 나타내는 헝가리안 표기법을 더하는 것도 좋다. 8.1.2. 공백과 탭 공백을 선호하는 추세로 바뀌고 있으나, 탭은 1바이트라는 장점을 가지고 있다. 이 책에서는 4칸이 가독성이 더 좋다고 했다. 8.1.3. 중괄호를 여는 위치 중괄호는 줄바꿈하지 않는 것이 좋고, 줄바꿈을 한다면 오동작을 주의해야 한다. Javascript는 세미콜론 사용에 대한 규칙을 느슨하게 적용하는데,  다음 줄에 결과를 주더라도 으로 만들어 버리기 때문이다. 8.1.4. strict mode ECMAScript 5가 권장하는 방법이다. 파일이나 함수에 추가함으로서 설정 가능하다. strict 모드에서 제한 되는 내용은 다음과 같다. scope 내부에서 var 없이 global…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-8/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 8. Javascript 코딩과 개발 환경","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"7.1.  태그위치와 레이지 로드  태그위치 는 block mode로 작동한다. script가 다 실행 될때까지 화면이 렌더링 되지 않는다. 그 이유는 로 html을 쓸 수도 있기 때문이라 한다. 따라서  태그는 html 문서의 가장 아래 쪽에 위치하는 것이 좋다. Lazy Load For Script File 위와 같은 blocking현상을 막기 위해서 lazy load를 구현하는 것이다. lazy load는 와 를 이용해서 다음과 같이 구현한다.  를 이용할 수 있지만, 이 방식은 다수의 이벤트 핸들러를 등록하지 못하므로 기존에 등록되어 있던 것을 다 덮어 써버릴 염려가 있다. Lazy Load For Image File…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-7/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 7. JavaScript 성능과 사용자 경험 개선","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"6.1. 단일 스레드 환경 브라우저 환경의 가장 큰 특징은 single thread 방식이라는 점이다. JavaScript 런타임은 처리해야 하는 요청을 순차적으로 처리하기 위해서 Queue(event queue/task queue, 이 책에서는 스레드 큐라는 용어를 사용)를 사용한다. setTimeout(0)의 의미는? setTimeout(0)은 “즉시, 메세지큐에 새로운 메세지를 등록하라”는 뜻이다. 역시 이책은 명확하게 정의하지 않는다. 이곳과 이곳 참고하여 setTimeout을 정의하면 다음과 같다. setTimeout(func,n)은 “n밀리초 후에 func를 큐에 등록하라”는 뜻이다. 이렇게 하면 등록 전담 스레드가 있어야 할 것 같지만 정확한 구현은 알 수 없다. 적어도 메세지를 즉시 큐에 등록하고 n…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-6/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 6. 브라우저 환경에서의 JavaScript","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"이 책에서는 자주 볼 수있는 유용한 패턴을 몇가지 소개하고 있다. 5.2. 모듈 패턴 소스를 모듈 단위로 관리하기 위해서 쓰이는 패턴이다. 대표적인 예로 jQuery의 를 들 수 있다. 위와 같이  에 등록하는 방법, 아래와 같이 리턴을 받아서 할당하는 방법이 있다. 5.2. 이벤트 델리게이션 패턴 이 책에서는 정의를 제대로 내리지 않고 유용한 상황을 먼저 설명하고 있다. 아래는 내가 정의한 이벤트 델리게이션이다. 이벤트 델리게이션 패턴이란 다수의 element에 각각에 event handler를 할당하는 것이 아니라, 그 것을 감싸는 부모 element에 하나의 event handler만 할당하여 처리하는 방식이다. 이 때, 조건문을 통해서 각 element…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-5/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 5. 디자인 패턴 실용","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"4.1. 프로토타입을 통한 객체지향 4.1.1. 프로토타입의 정의 프로토타입이란 Javascript가 제공하는 객체 지향을 지원하기 위한 방법이다. Java의 상속과는 다르게 동적으로 부모 객체의 수정이 가능하다. 4.1.2. JavaScript와 자바의 객체 생성 비교 자바와 비슷하지만 JavaScript는 function으로 선언한다. 단, ECMAScript 6에서는 class 키워드가 추가되었다. 4.1.3. this의 이해 JavaScript에서의 this 가 무엇을 참조하는지는 “호출 방법” 에 따라서 변경이 된다. (스코프가 아님) 일반 함수 내에서의 this는 Window 객체를 참조한다. 맴버 함수 내에서의 this는 해당 함수를 포함하는 객체를 참조한다 call()과 apply()는 첫 번째 파라미터로 this…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-4/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 4. 프로토타입과 객체지향, 그리고 상속","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"3.1. JavaScript의 기본 형과 typeof javascript의 기본형 객체가 아닌 기본적인 키워드로 활용할 수 있는 기본형. number string boolean undefined null symbol typeof의 결과 목록 typeof는 문자열을 반환한다. “undefined” “boolean” “number” “string” “object” “function” “symbol” typeof의 결과 중 특이 한 것 “typeof null은 object이다.” 따라서, typeof를 이용해서 object인지 체크한 뒤 어떤 동작을 추가하려면, null 체크를 따로 먼저 해주는 것이 좋다. 3.2. new String(\"\"), String(\"\"), 그리고 \"\" Javascript의 문자열은 기본형(primitive)과 객체형 두가지 형태로 존재한다. new String()은 래퍼객체이고, \"\"과 String(\"\")은 기본형이다 String…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-3/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 3. JavaScript의 변수","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"2.1. 스코프란? 다른 프로그래밍 언어를 다루다가 JavaScript를 접하게 된 프로그래머가 반드시 한번 빠지게 되는 함정이 있다. JavaScript는 일반적인 프로그래밍 언어의 블록 스코프를 따르지 않는다. 2.1.1. 스코프의 생성 JavaScript에서 스코프를 생성하는 구문은 세가지가 있다. function을 이용한 스코프 생성 foo() 내부에서 선언된 변수를 외부에서 접근할 수 없다. catch을 이용한 스코프 생성 catch의 인자(이 경우에는 err)만 내부 스코프에 포함 된다. 선언된 변수(이 경우에는 test)는 외부 스코프에 포함된다. with을 이용한 스코프 생성 with 구문도 catch 처럼 인자가 내부 스코프에 포함 된다. 2.1.2. 스코프의 지속성 다른 언어와 다른 JavaScript…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-2/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 2. JavaScript의 스코프와 클로저","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"1.1. JavaScript의 어제와 오늘  창을 띄워 가며 디버깅 하던 시절이 있었다. 문법에러를 잡아 주지 않았기에 디버깅도 어려웠다. 지금은 다양한 디버깅 툴과 IDE 등의 등장으로 개발 환경이 확연히 달라졌다. JavaScript와 자바와의 관계는 햄과 햄버거의 관계이다 그럴듯한 비유이다. 둘의 이름은 공통된 부분이 있지만, 그닥 관계있는 음식은 아니다. 자바와 JavaScript는 무관하다고 하다고 말할 수 있을 정도로 전혀 관련이 없다. 역사적으로는 Netscape가 개발한 Livescript를 Sun Microsystems가 협업하면서 전략적으로 이름을 Javascript로 바꾼 것이다. 1.2. 웹 개발 방법론의 변화 2000년 이전의 웹 HTML 파일로 제공하는 텍스트 정보가 주를 이루었다. 또한 대부분 정적인 정보를 제공하는 웹페이지가 주를 이루었다. 포털이나 이메일 처럼 동적인 페이지를 생성하는 서버는 Perl과 CGI(Common Gateway Interface…","fields":{"slug":"/2020/11/26/deep-javascript-chapter-1/"},"frontmatter":{"date":"November 26, 2020","title":"속깊은 JavaScript, Chapter 1. 웹과 JavaScript","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}},{"node":{"excerpt":"속깊은 JavaScript는 2017년에 읽었던 JavaScript 책 중 하나였다. 개인적으로 궁금했던 부분을 많이 담고 있어서 구매 했고, 독서의 효과를 높이기 위해서 예제코드와 본문을 나의 언어로 바꾸어 정리하기로 마음 먹었다. 목표를 만들면 완독까지 가기가 더 쉬워지기 때문이다. 그리 두껍지 않은 책인데다가 최대한 요약 정리만 했음에도 꽤 많은 분량이다.  챕터별 링크 Chapter 1. 웹과 JavaScript Chapter 2. JavaScript의 스코프와 클로저 Chapter 3. JavaScript의 변수 Chapter 4. 프로토타입과 객체지향, 그리고 상속 Chapter 5. 디자인 패턴 실용 Chapter 6. 브라우저 환경에서의 JavaScript Chapter 7. JavaScript 성능과 사용자 경험 개선 Chapter 8. Javascript 코딩과 개발 환경 Chapter 9. JavaScript 표준","fields":{"slug":"/2020/11/26/deep-javascript/"},"frontmatter":{"date":"November 25, 2020","title":"속깊은 JavaScript 빠르게 읽기","description":null,"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQoz2NgmNaBhhhBZCfvlGbV3jKl7hK2Ka1ALqYyEMIUYp7azjCzP7g56XOe/pNqF+2+CqBmpmntRGlmmdrGMKs/piH2f7bGr3oP/c4Chr4qpslNDNM7idAMJGd0q/RW5NREJJV4i7XlMHSVMU9sIKAZ5NupbWYr5/mvX+a+caXnto0eG5a6LJ6QvG6e1bLZDFPamNA8j2kz74xukVm9IrP7xKZ1iHeXC3YUKU5p4p3ZTZSfGeBhM7WVoa2Qoa2Yob0Y6CIiNXcwdNUxtFYxtFYwdFQwdNcz9gFDi7ioAvqNob6EoaoAhBrLoeT0TqJtBiKIaqCFU2EIQw0A6irj958ycMgAAAAASUVORK5CYII=","aspectRatio":2,"src":"/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png","srcSet":"/static/618cb49fb7a47f960affa92121351514/95f17/thumbnail1.png 150w,\n/static/618cb49fb7a47f960affa92121351514/37d5a/thumbnail1.png 300w,\n/static/618cb49fb7a47f960affa92121351514/3891b/thumbnail1.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}}}}}]}},"pageContext":{"category":"JavaScript"}},"staticQueryHashes":["2841359383","2911494500","3200528885"]}